[{"title":"Travis CI 自动部署 Hexo","date":"2017-07-23T19:57:08.000Z","path":"2017/07/23/Travis-Hexo/","text":"介绍利用软件开发中的持续集成工具 Travis CI 来帮助完成 Hexo 的自动部署。 登陆 GitHub，进入设置界面，在 Personal access tokens 页面下点击右上角的 Generate new token 按钮会生成新的 token，随后输入密码，取个名字，勾选一些权限。 登陆 Travis CI，使用 GitHub 账户登录，它会自动关联 GitHub 上的仓库。点击右上角用户查看 GitHub 仓库，并选择要启动的项目，这里选择 yourname/yourname.github.io。点击设置按钮，进入设置选项，开启相关服务，Build only if .travis.yml is present：指只在有.travis.yml时改变了才构建；Build pushes：push 完分支后开始构建。 拷贝 token 并在 Travis CI 页面中配置Environment Variables，我这里取名为 __GITHUB_TOKEN__。那么 Travis CI 已获得仓库权限，现在可以给它相关操作指令了。 配置 .travis.yml （存放在博客根目录下）.travis.yml 内容如下： 1234567891011121314151617language: node_jsnode_js:- 6.10.3branches: only: - hexoinstall:- npm install -g hexo-cli- npm installbefore_script:- git config --global user.name &quot;iChenwin&quot;- git config --global user.email &quot;iChenwin@gmail.com&quot;- sed -i &quot;s/__GITHUB_TOKEN__/$&#123;__GITHUB_TOKEN__&#125;/&quot; _config.ymlscript: hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy 最后，更改博客 _config.yml 的 deploy 项，不能用 ssh， 要改成 https： 1234deploy: type: git repository: https://__GITHUB_TOKEN__@github.com/iChenwin/ichenwin.github.io.git branch: master 参考：http://www.jianshu.com/p/5e74046e7a0f","tags":[{"name":"hexo","slug":"hexo","permalink":"http://ichenwin.github.io/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://ichenwin.github.io/tags/博客/"}]},{"title":"iOS扫描二维码","date":"2017-06-17T10:04:08.000Z","path":"2017/06/17/barcode-ios/","text":"导入AVFoundation库，并将它加入.pch预编译文件 给相机预览控制器DTCameraPreviewController添加四个私有成员，获取AVFoundation的“终端”、“输入”、“输出”、“管理员”对象： 1234567891011121314@implementation DTCameraPreviewController&#123; AVCaptureDevice *_camera; AVCaptureDeviceInput *_videoInput; AVCaptureStillImageOutput *_imageOutput; AVCaptureSession *_captureSession;&#125; 选取录制设备（摄像头或麦克风） AVCaptureDevice提供了一个类方法，指定一种媒体类型（AVMediaTypeVideo or AVMediaTypeAudio）它便能返回对应的录制设备。其他媒体类型可以在AVMediaFormat.h中找到，不过它们不需要录制设备（如文本、字幕等）。 在DTCameraPreviewController.m中实现_setupCamera方法，用来初始化若干个AVFoundation中用于录制的对象， 123456789101112131415161718192021222324- (void)_setupCamera &#123; //获取到一个录制设备（摄像头） _camera = [AVCaptureDevice defaultDeviceWithMediaType: AVMediaTypeVideo]; //创建摄像头的输入，initWithDevice:方法自动为设备分配了一个端口，每个端口只能传输一路媒体数据 NSError *error; _videoInput = [[AVCaptureDeviceInput alloc] initWithDevice:_camera error:&amp;error]; if (!_videoInput) &#123; NSLog(@\"Error connecting video input: %@\", [error localizedDescription]); return; &#125;&#125; 媒体录制“管理进程” AVCaptureSession是媒体录制进程的的管理员。控制着设备的输入输出。将输入添加至设备（_setupCamera方法）： 1234567891011121314//创建录制“管理进程”，将输入添加至设备_captureSession = [[AVCaptureSession alloc] init];if (![_captureSession canAddInput:_videoInput]) &#123; NSLog(@\"Unable to add video input to capture session\"); return;&#125;[_captureSession addInput:_videoInput]; 显示实时视频预览 苹果提供了预览层AVCaptureVideoPreviewLayer，它可以提供摄像头画面的实时预览。因为它是CALayer的子类，将它封装至UIView，方便使用。所以新建一个继承自UIView的DTVideoPreviewView类。头文件中，定义一个属性以获取视频预览层： 123456@interface DTVideoPreviewView : UIView@property (readonly) AVCaptureVideoPreviewLayer *previewLayer;@end 实现文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@implementation DTVideoPreviewView//代码创建实例时调用- (id)initWithFrame:(CGRect)frame &#123; self = [super initWithFrame:frame]; if (self) &#123; [self _commonSetup]; &#125; return self;&#125;//通过Nib创建- (void)awakeFromNib &#123; [self _commonSetup];&#125;//替代默认的CALayer+ (Class)layerClass &#123; return [AVCaptureVideoPreviewLayer class];&#125;- (void)_commonSetup &#123; self.autoresizingMask = UIViewAutoresizingFlexibleHeight | UIViewAutoresizingFlexibleWidth; self.backgroundColor = [UIColor blackColor]; [self.previewLayer setVideoGravity:AVLayerVideoGravityResizeAspectFill]; &#125;//类型转换- (AVCaptureVideoPreviewLayer *)previewLayer &#123; return (AVCaptureVideoPreviewLayer *)self.layer;&#125;@end 将storyboard中的根视图类型改为DTVideoPreviewView。 在DTCameraPreviewController中添加以下viewDidLoad方法： 123456789101112- (void)viewDidLoad &#123; [super viewDidLoad]; NSAssert([self.view isKindOfClass:[DTVideoPreviewView class]], @\"Wrong root view class %@ in %@\", NSStringFromClass([self.view class]), NSStringFromClass([self class])); _videoPreview = (DTVideoPreviewView *)self.view; [self _setupCamera];&#125; 以及在_setupCamera最后将预览图层添加至管理进程中： 12_videoPreview.previewLayer.session = _captureSession; 至此，我们已将流程图中的AVCaptureDeviceInput连至预览图层。 启动摄像头需调用-startRunning 123456789101112131415161718- (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; [_captureSession startRunning];&#125;- (void)viewDidDisappear:(BOOL)animated &#123; [super viewDidDisappear:animated]; [_captureSession stopRunning];&#125; 设置闪光灯 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152- (void)_setupTorchToggleButton &#123; if ([_camera hasTorch]) &#123; self.toggleTorchButton.hidden = NO; &#125; else &#123; self.toggleTorchButton.hidden = YES; &#125;&#125;- (IBAction)toggleTorch:(id)sender &#123; if ([_camera hasTorch]) &#123; BOOL torchActive = [_camera isTorchActive]; if ([_camera lockForConfiguration:nil]) &#123; if (torchActive) &#123; if ([_camera isTorchModeSupported:AVCaptureTorchModeOff]) &#123; [_camera setTorchMode:AVCaptureTorchModeOff]; &#125; &#125; else &#123; if ([_camera isTorchModeSupported:AVCaptureTorchModeOn]) &#123; [_camera setTorchMode:AVCaptureTorchModeOn]; &#125; &#125; [_camera unlockForConfiguration]; &#125; &#125;&#125; 抓取照片 完整的_setupCamera： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374- (void)_setupCamera &#123; _camera = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo]; if (!_camera) &#123; [self.snapButton setTitle:@\"No Camera Found\" forState:UIControlStateNormal]; self.snapButton.enabled = NO; [self _informUserAboutNoCam]; return; &#125; NSError *error; _videoInput = [[AVCaptureDeviceInput alloc] initWithDevice:_camera error:&amp;error]; if(!_videoInput) &#123; NSLog(@\"error connectiong video input: %@\", [error localizedDescription]); return; &#125; _captureSession = [[AVCaptureSession alloc] init]; if (![_captureSession canAddInput:_videoInput]) &#123; NSLog(@\"Unable to add video input to capture session\"); return; &#125; [_captureSession addInput:_videoInput]; // [self _configureCurrentCamera]; _imageOutput = [AVCapturePhotoOutput new]; if (![_captureSession canAddOutput:_imageOutput]) &#123; NSLog(@\"Unable to add still image output to capture session\"); return; &#125; [_captureSession addOutput:_imageOutput]; _videoPreview.previewLayer.session = _captureSession;&#125; 获取当前链路： 1234567891011121314151617181920- (AVCaptureConnection *)_captureConnection &#123; for (AVCaptureConnection *connection in _imageOutput.connections) &#123; for (AVCaptureInputPort *port in [connection inputPorts]) &#123; if ([port.mediaType isEqual:AVMediaTypeVideo]) &#123; return connection; &#125; &#125; &#125; return nil; &#125; 拍照： 123456789101112131415161718192021222324252627282930313233343536373839404142- (IBAction)snap:(id)sender &#123; if (!_camera) &#123; return; &#125; AVCaptureConnection *videoConnection = [self _captureConnection]; if (!videoConnection) &#123; NSLog(@\"Error:No Video connection found on still image output\"); &#125; [_imageOutput captureStillImageAsynchronouslyFromConnection:videoConnection completionHandler:^(CMSampleBufferRef imageSampleBuffer, NSError *error) &#123; if (error) &#123; NSLog(@\"Error capturing still image: %@\", [error localizedDescription]); return; &#125; NSData *imageData = [AVCaptureStillImageOutput jpegStillImageNSDataRepresentation: imageSampleBuffer]; UIImage *image = [UIImage imageWithData:imageData]; UIImageWriteToSavedPhotosAlbum(image, nil, nil, nil); &#125;];&#125; 对焦 iOS有三种对焦模式： 123456AVCaptureFocusModeContinuousAutoFocusAVCaptureFocusModeAutoFocusAVCaptureFocusModeLocked 监测扫描区域的变化： 123456789101112131415161718- (void)_configureCurrentCamera &#123; if ([_camera isFocusModeSupported:AVCaptureFocusModeLocked]) &#123; if ([_camera lockForConfiguration:nil]) &#123; _camera.subjectAreaChangeMonitoringEnabled = YES; [_camera unlockForConfiguration]; &#125; &#125;&#125; 一旦画面有变化，iOS系统就会发出AVCaptureDeviceSubjectAreaDidChangeNotification通知，我们可以再-viewDidLoad中订阅这一通知： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. NSAssert([self.view isKindOfClass:[CWVideoPreviewView class]], @\"Wrong root view class %@ in %@\", NSStringFromClass([self.view class]), NSStringFromClass([self class])); _videoPreview = (CWVideoPreviewView *)self.view; [self _setupCamera]; _videoPreview.previewLayer.session = _captureSession; [self _setupCameraAfterCheckingAuthorization]; UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(handleTap:)]; [self.view addGestureRecognizer:tap]; NSNotificationCenter *center = [NSNotificationCenter defaultCenter]; [center addObserver:self selector:@selector(subjectChanged:) name:AVCaptureDeviceSubjectAreaDidChangeNotification object:nil];&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"CSDN文章导出，Python批处理更改文件名，添加文件描述","date":"2017-06-03T10:04:08.000Z","path":"2017/06/03/csdn-export/","text":"想把CSDN博客同步到拿GitHub Page搭的独立博客上去，找了下，发现有人用Python写了个工具，可以将博客导出为Markdown和HTML格式：csdn-blog-export 把它搬到了百度盘，链接: http://pan.baidu.com/s/1o8fpxGI 密码: pgbb 用法很简单（注意：博客主题需切回“碧海蓝”，我的“极客世界”主题失效）：./main.py -u CSDN用户名 -f markdown或./main.py -u CSDN用户名 -f markdown 便能得到我们博客的所有博文。拿到博文后，我想把它改为Hexo接受的格式，主要是在.md格式文件头添加一段文件描述，像这样：12345title: Hello Worlddate: 2014-05-27 10:04:08tag: 博客category: 博客建设--- 顺便把文件名该为博文名。于是自己写了个Python脚本：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/usr/bin/python# -*- coding: UTF-8 -*-import osimport re#解析博文HTML，获取博文时间、标题标签from bs4 import BeautifulSoup#解决中文编码问题import codecsmdPath = '/Users/wayne/blogposts/'htmlPath = '/Users/wayne/blogposts/html/'mdPosts = os.listdir(mdPath)for postName in mdPosts: if postName.endswith('.md'): #备份工具得到的文件名像这样：21049457.md，对当前文件夹中.md文件进行操作 #获取文件名中8位数字，存于prefix中，用于匹配和它对应的HTML文件 #然后从HTML文件中挖出博文发布时间，保存在timeStamp中 prefix = postName[:8] html = open(htmlPath + prefix + '.html', 'r') soup = BeautifulSoup(html) tag = soup.find_all('span', class_=\"link_postdate\") timeStamp = tag[0].string print timeStamp #从HTML中获取博客标题，用于重命名.md文件 title = soup.title temp = title.string pos = temp.index(\" - \") newFileName = temp[:pos] print newFileName #弃用！ #.md文件中第一行大致长这样：# [ Objective-C常用宏定义 ](/ichenwin/article/details/52813659) #方括号中就是博文名，下面这段代码负责从.md文件第一行获取文章名 # mdFile = codecs.open(mdPath + postName, \"r\", 'utf-8') # contents = mdFile.readlines() # firstLine = contents.pop(0) # print \"firstline:\" + firstLine # newFileName = re.compile('\\[([^]]+)\\]').findall(firstLine)[0] # mdFile.close() #将.md中博文读入contents，往contents插入Hexo头部 #然后写回.md文件 mdFile = codecs.open(mdPath + postName, \"r\", 'utf-8') contents = mdFile.readlines() mdFile.close() contents.insert(0, \"---\\n\") contents.insert(0, u\"category: 技术笔记\\n\") contents.insert(0, \"tags: iOS\\n\") contents.insert(0, \"date: \" + timeStamp + \"\\n\") contents.insert(0, \"title: \" + newFileName + \"\\n\") mdFile = codecs.open(postName, \"w\", 'utf-8') newContents = \"\".join(contents) mdFile.write(newContents) mdFile.close() html.close() #重命名.md文件 os.rename(os.path.join(mdPath, postName), os.path.join(mdPath, newFileName + \".md\"))","tags":[{"name":"博客","slug":"博客","permalink":"http://ichenwin.github.io/tags/博客/"}]},{"title":"给UIView（如：UIButton）添加虚线边框","date":"2017-05-22T14:34:00.000Z","path":"2017/05/22/给UIView(如：UIButton）添加虚线边框 /","text":"要给 UIButton 等视图加一圈虚线边框，这里是其中一种方法，就是在原来的视图的 layer 上再添加一层 CAShapeLayer ，在这一层中使用贝塞尔曲线 UIBezierPath 的 lineDashPattern 创建虚线边框。 UIView *view = [[UIView alloc] init]; CAShapeLayer *layer = [[CAShapeLayer alloc] init]; layer.frame = CGRectMake(0, 0 , view.frame.size.width, view.frame.size.height); layer.backgroundColor = [UIColor clearColor].CGColor; UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:layer.frame cornerRadius:4.0f]; layer.path = path.CGPath; layer.lineWidth = 4.0f; layer.lineDashPattern = @[@4, @4]; layer.fillColor = [UIColor clearColor].CGColor; layer.strokeColor = [UIColor whiteColor].CGColor; [view.layer addSublayer:layer];","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"给UIView（如：UIButton）添加虚线边框","date":"2017-05-22T14:34:00.000Z","path":"2017/05/22/给UIView（如：UIButton）添加虚线边框 /","text":"要给 UIButton 等视图加一圈虚线边框，这里是其中一种方法，就是在原来的视图的 layer 上再添加一层 CAShapeLayer ，在这一层中使用贝塞尔曲线 UIBezierPath 的 lineDashPattern 创建虚线边框。 UIView *view = [[UIView alloc] init]; CAShapeLayer *layer = [[CAShapeLayer alloc] init]; layer.frame = CGRectMake(0, 0 , view.frame.size.width, view.frame.size.height); layer.backgroundColor = [UIColor clearColor].CGColor; UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:layer.frame cornerRadius:4.0f]; layer.path = path.CGPath; layer.lineWidth = 4.0f; layer.lineDashPattern = @[@4, @4]; layer.fillColor = [UIColor clearColor].CGColor; layer.strokeColor = [UIColor whiteColor].CGColor; [view.layer addSublayer:layer];","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"NavigationBar返回按钮设置","date":"2017-05-19T16:25:00.000Z","path":"2017/05/19/NavigationBar返回按钮设置 /","text":"NavigationBar 中返回按钮 title 的设置，要在父视图中完成，假设A视图（AViewController）包裹在导航视图中（NavigationVC），它通过 pushViewController 将B视图（BViewController）压入栈中，要想更改B视图的返回按钮，需在A视图中添加设置代码： UIBarButtonItem *backItem = [[UIBarButtonItem alloc] initWithTitle:@&quot;back&quot; style:UIBarButtonItemStylePlain target:nil action:nil]; self.navigationItem.backBarButtonItem = backItem; 返回按钮字体样式设置，这有一种方法（ 注意 ：一旦运行了这段代码，APP中的 所有导航栏 返回按钮样式都随之改变。如果符合需求，可以这样用。我将它写在 AppDelegate.m 的 didFinishLaunchingWithOptions: 里） //设置“返回”字体的阴影 NSShadow *shadow = [[NSShadow alloc] init]; shadow.shadowOffset = CGSizeMake(-1.0, 1.0); shadow.shadowColor = [UIColor blackColor]; [[UIBarButtonItem appearanceWhenContainedIn:[UINavigationBar class], nil] setTitleTextAttributes: @{NSForegroundColorAttributeName:[UIColor colorWithRed:252/255.0 green:242/255.0 blue:237/255.0 alpha:1.0], NSShadowAttributeName:shadow, NSFontAttributeName:[UIFont systemFontOfSize:20.0] } forState:UIControlStateNormal];","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"iOS系统音量控制——MPVolumeView","date":"2017-05-15T17:39:00.000Z","path":"2017/05/15/iOS系统音量控制——MPVolumeView /","text":"iOS的音量控制接口在 MediaPlayer 库中，1. 首先要将该库导入：2. 然后在用到的地方引入 MPVolumeView 的头文件：#import &lt;MediaPlayer/MPVolumeView.h&gt;3. 而 MPVolumeView 中负责控制音量的是它的子视图 MPVolumeSlider，而这个类并未对外公开，所以要去控制它，需要遍历 volumeView 的子视图，把它找出来，并赋值： MPVolumeView *volumeView = [{MPVolumeView alloc] init]; UISlider *volumeViewSlider = nil; for (UIView *view in [volumeView subviews]) { if ([view.class.description isEqualToString:@&quot;MPVolumeSlider&quot;]) { volumeViewSlider = (UISlider *)view; break; } } // change system volume, the value is between 0.0f and 1.0f [volumeViewSlider setValue:0.3f animated:NO]; // send UI control event to make the change effect right now. 立即生效 [volumeViewSlider sendActionsForControlEvents:UIControlEventTouchUpInside]; 然后就可以通过控制 volumeViewSlider 去控制系统音量了。这种情况下，调节音量时会显示系统音量提示框，若要关掉，需将 volumeView 添加至当前视图，如不需要 volumeView，可以将它设置到视图外，隐藏掉它： [volumeView setFrame:CGRectMake(-1000, -100, 100, 100)]; [self.view addSubview:volumeView]; demo地址： VolumePanel (未隐藏 volumeView )","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"PC上浏览微信文章","date":"2017-04-20T07:53:00.000Z","path":"2017/04/20/PC上浏览微信文章 /","text":"电脑上有时会有打不开微信文章的问题，提示“请在微信客户端打开链接。”。在chrome中，F12打开调试窗口，切换至手机版，新添加一手机模拟器，在 User Agent String 框里面填写以下信息 ： &quot;Mozilla/5.0 (linux; U; Android 2.3.6; zh-cn; GT-S5660 Build/GINGERBREAD) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1 MicroMessenger/4.5.255&quot;","tags":[{"name":"Web","slug":"Web","permalink":"http://ichenwin.github.io/tags/Web/"}]},{"title":"python读取csv文件","date":"2017-04-18T13:55:00.000Z","path":"2017/04/18/python读取csv文件 /","text":"读取 .csv 文件，获取Email地址，用逗号串联，存入文本文件。最后统计取得的Email个数： #!/usr/bin/env python # -*- coding: utf-8 -*- import csv output = open(&apos;out.txt&apos;, &apos;wb&apos;) with open(‘contact.csv’, ‘rb’) as csvfile: spamreader = csv.reader(csvfile, delimiter=’ ‘, quotechar=’|’) for row in spamreader: for item in row: output.write(item + ‘,’) output.close() result = open(&apos;out.txt&apos;, &apos;rb&apos;) data = result.read() print data.count(&apos;@&apos;) out.close()","tags":[{"name":"Python","slug":"Python","permalink":"http://ichenwin.github.io/tags/Python/"}]},{"title":"JavaScript学习笔记","date":"2017-04-09T15:51:00.000Z","path":"2017/04/09/JavaScript学习笔记 /","text":"引自廖雪峰老师的教程： JavaScript教程 1. 基本语法(1).JavaScript代码通常放在 &lt;head&gt; 标签中，可以直接放在 &lt;script&gt; 标签里： &lt;html&gt; &lt;head&gt; &lt;script&gt; alert(&apos;Hello, world&apos;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; ... &lt;/body&gt; &lt;/html&gt; 或者把JavaScript代码单独放在 .js 文件，然后HTML引用： &lt;html&gt; &lt;head&gt; &lt;script src=&quot;/static/js/abc.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; ... &lt;/body&gt; &lt;/html&gt; 2.数据类型(1).JavaScript不区分整型和浮点型，统一用Number表示。123; // 整数123 0.456; // 浮点数0.456 1.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5 -99; // 负数 NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示 Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity (2).比较运算符相等运算符==。JavaScript在设计时，有两种比较运算符： 第一种是 == 比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；第二种是 === 比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。 由于JavaScript这个设计缺陷， _ 不要 _ 使用 == 比较，始终坚持使用 === 比较。 另一个例外是NaN这个特殊的Number与所有其他值都不相等，包括它自己： NaN === NaN; // false 唯一能判断NaN的方法是通过isNaN()函数： isNaN(NaN); // true 最后要注意浮点数的相等比较： 1 / 3 === (1 - 2 / 3); // false 这不是JavaScript的设计缺陷。浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值： Math.abs(1 / 3 - (1 - 2 / 3)) &lt; 0.0000001; // true (3).对象JavaScript的对象是一组由键-值组成的无序集合，例如： var person = { name: &apos;Bob&apos;, age: 20, tags: [&apos;js&apos;, &apos;web&apos;, &apos;mobile&apos;], city: &apos;Beijing&apos;, hasCar: true, zipcode: null }; JavaScript对象的键都是字符串类型，值可以是任意数据类型。上述person对象一共定义了6个键值对，其中每个键又称为对象的属性，例如，person的name属性为’Bob’，zipcode属性为null。要获取一个对象的属性，我们用对象变量.属性名的方式： person.name; // &apos;Bob&apos; person.zipcode; // null (4).数组数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。例如： [1, 2, 3.14, &apos;Hello&apos;, null, true]; 上述数组包含6个元素。数组用[]表示，元素之间用,分隔。另一种创建数组的方法是通过Array()函数实现： new Array(1, 2, 3); // 创建了数组[1, 2, 3] 然而，出于代码的可读性考虑，强烈建议直接使用[]。 3.变量(1).变量赋值可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意只能用var申明一次，例如： var a = 123; // a的值是整数123 a = &apos;ABC&apos;; // a变为字符串 这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。 (2).strict模式JavaScript在设计之初，为了方便初学者学习，并不强制要求用var申明变量。这个设计错误带来了严重的后果：如果一个变量没有通过var申明就被使用，那么该变量就自动被申明为全局变量： i = 10; // i现在是全局变量 在同一个页面的不同的JavaScript文件中，如果都不用var申明，恰好都使用了变量i，将造成变量i互相影响，产生难以调试的错误结果。使用var申明的变量则不是全局变量，它的范围被限制在该变量被申明的函数体内，同名变量在不同的函数体内互不冲突。启用strict模式的方法是在JavaScript代码的第一行写上： &apos;use strict&apos;;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ichenwin.github.io/tags/JavaScript/"}]},{"title":"显示NavigationController（NavigationBar）和完成返回动作","date":"2017-03-30T16:37:00.000Z","path":"2017/03/30/显示NavigationController（NavigationBar）和完成返回动作/","text":"在要跳转至下一个 ViewController 处，创建一个 NavigationController ，并将下一个 VC作为它的根 VC ，然后显示 NavigationController （ NavigationController 中只有一个 VC ，所以也就是显示下一个 VC ）： NextViewController *vc = [[NextNViewController alloc] init]; UINavigationController *navigationController = [[UINavigationController alloc] initWithRootViewController:vc]; [self presentViewController:navigationController animated:YES completion:^{ }]; 接着，在 NextViewController 添加返回按钮，并返回父视图： - (void)viewWillAppear:(BOOL)animated { UIBarButtonItem *backItem = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemDone target:self action:@selector(goBack)]; [self.navigationItem setLeftBarButtonItem:backItem]; } - (void)goBack { [self.navigationController dismissViewControllerAnimated:YES completion:^{ }]; }","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"UICollectionView的Cell加载动画","date":"2017-03-10T16:24:00.000Z","path":"2017/03/10/UICollectionView的Cell加载动画 /","text":"-(void)collectionView:(UICollectionView *)collectionView willDisplayCell:(UICollectionViewCell *)cell forItemAtIndexPath:(NSIndexPath *)indexPath { // CGAffineTransformMake(a,b,c,d,tx,ty) // ad缩放bc旋转tx,ty位移，基础的2D矩阵 cell.transform = CGAffineTransformMakeScale(1.4, 1.4);//CGAffineTransformMake(1.4, 0, 0, 1.4, 10, 10); [UIView animateWithDuration:0.5 delay:0.0 options:UIViewAnimationOptionCurveEaseInOut animations:^{ cell.transform = CGAffineTransformIdentity; } completion:nil]; }","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"WWDC2014之App Extensions学习笔记","date":"2017-02-23T21:01:00.000Z","path":"2017/02/23/WWDC2014之App Extensions学习笔记 /","text":"好文，原博文： [ http://foggry.com/blog/2014/06/23/wwdc2014zhi-app-extensionsxue-xi-bi-ji/ ](http://foggry.com/blog/2014/06/23/wwdc2014zhi-app-extensionsxue-xi-bi-ji/) 一、关于App Extensionsextension是iOS8新开放的一种对几个固定系统区域的扩展机制，它可以在一定程度上弥补iOS的沙盒机制对应用间通信的限制。 extension的出现，为用户提供了在其它应用中使用我们应用提供的服务的便捷方式，比如用户可以在 Today 的 widgets 中查看应用展示的简略信息，而不用再进到我们的应用中，这将是一种全新的用户体验；但是，extension的出现可能会减少用户启动应用的次数，同时还会增大开发者的工作量。 几个关键词 extension point 系统中支持extension的区域，extension的类别也是据此区分的，iOS上共有 Today 、 Share 、 Action 、 Photo Editing 、 Storage Provider 、 Custom keyboard 几种，其中 Today 中的extension又被称为 widget 。 每种extension point的使用方式和适合干的活都不一样，因此不存在通用的extension。 app extension 即为本文所说的extension。extension并不是一个独立的app，它有一个包含在appbundle中的独立bundle，extension的bundle后缀名是 .appex 。其生命周期也和普通app不同，这些后文将会详述。 extension不能单独存在，必须有一个包含它的containing app。 另外，extension需要用户手动激活，不同的extension激活方式也不同，比如： 比如Today中的widget需要在Today中激活和关闭； Custom keyboard 需要在设置中进行相关设置； Photo Editing 需要在使用照片时在照片管理器中激活或关闭； Storage Provider 可以在选择文件时出现； Share 和 Action 可以在任何应用里被激活，但前提是开发者需要设置Activation Rules ，以确定extension需要在合适出现。 containing app 尽管苹果开放了extension，但是在iOS中extension并不能单独存在，要想提交到AppStore，必须将extension包含在一个app中提交，并且app的实现部分不能为空,这个包含extension的app就叫containing app。 extension会随着containing app的安装而安装，同时随着containing app的卸载而卸载。 host app 能够调起extension的app被称为host app，比如 widget 的host app就是 Today 。 二、extension和containing app、host app2.1 extension和host appextension和host app之间可以通过extensionContext属性直接通信，该属性是新增加的UIViewController类别： 1 2 3 4 5 6 @interface UIViewController(NSExtensionAdditions) &lt;NSExtensionRequestHandling&gt; // Returns the extension context. Also acts as a convenience method for a view controller to check if it participating in an extension request. @property (nonatomic,readonly,retain) NSExtensionContext *extensionContext NS_AVAILABLE_IOS(8_0); @end 实际上extension和host app之间是通过IPC（interprocesscommunication）实现的，只是苹果把调用接口高度抽象了，我们并不需要关注那么底层的东西。 2.2 containing app和host app他们之间没有任何直接关系，也从来不需要通信。 2.3 extension和containing app这二者之间的关系最复杂，纠纠缠缠扯不清关系。 不能直接通信 首先，尽管extension的bundle是放在containingapp的bundle中，但是他们是两个完全独立的进程，之间不能直接通信。不过extension可以通过openURL的方式启动containingapp（当然也能启动其它app），不过必须通过extensionContext借助host app来实现： 1 2 3 4 5 6 7 8 //通过openURL的方式启动Containing APP - (void)openURLContainingAPP { [self.extensionContext openURL:[NSURL URLWithString:@&quot;appextension://123&quot;] completionHandler:^(BOOL success) { NSLog(@&quot;open url result:%d&quot;,success); }]; } extension中是无法直接使用openURL的。 可以共享 Shared resources extension和containing app可以共同读写一个被称为 Shared resources 的存储区域，这是通过AppGroups实现的，后文将会详述。 三者间的关系可以通过官网给的两张图片形象地说明： containing app能够控制extension的出现和隐藏 通过以下代码，containing app可以让extension出现或隐藏（当然extension也可以让自己隐藏）： 1 2 3 4 5 6 7 8 9 10 11 //让隐藏的插件重新显示 - (void)showTodayExtension { [[NCWidgetController widgetController] setHasContent:YES forWidgetWithBundleIdentifier:@&quot;com.wangzz.app.extension&quot;]; } //隐藏插件 - (void)hiddeTodayExtension { [[NCWidgetController widgetController] setHasContent:NO forWidgetWithBundleIdentifier:@&quot;com.wangzz.app.extension&quot;]; } 三、App Groups这是iOS8新开放的功能，在OS X上早就可用了。它主要用于同一group下的app共享同一份读写空间，以实现数据共享。 extension和containingapp共同读写一份数据是很合理的需求，比如系统的股市应用，widget和app中都需要展示几个公司的股票数据，这就可以通过App Groups实现。 3.1 功能开启为了便于后续操作，请先确保你的开发者账号在Xcode上处于登录状态。 在app中开启 App Groups位于： 1 TARGETS--&gt;AppExtensionDemo--&gt;Capabilities--&gt;App Groups 找到以后，将App Groups右上角的开关打开，然后选择添加groups，比如我的是group.wangzz，当然这是为了测试随便起得名字，正规点得命名规则应该是：group.com.company.app。 添加成功以后如下图所示： 在extension中开启 我创建的是widget，target名称为TodayExtension，对应的App Groups位于： 1 TARGETS--&gt;TodayExtension--&gt;Capabilities--&gt;App Groups 开启方式和app中一样，需要注意的是必须保证这里地App Groups名称和app中的相同，即为group.wangzz。 四、extension和containing app数据共享App Groups给我们提供了同一group内app可以共同读写的区域，可以通过以下方式实现数据共享： 4.1 通过NSUserDefaults共享数据 存数据 通过以下方式向NSUserDefaults中保存数据： 1 2 3 4 5 6 7 - (void)saveTextByNSUserDefaults { NSUserDefaults *shared = [[NSUserDefaults alloc] initWithSuiteName:@&quot;group.wangzz&quot;]; [shared setObject:_textField.text forKey:@&quot;wangzz&quot;]; [shared synchronize]; } 需要注意的是： 1.保存数据的时候必须指明group id； 2.而且要注意NSUserDefaults能够处理的数据只能是可plist化的对象，详情见 Property List ProgrammingGuide 。 3.为了防止出现数据同步问题，不要忘记调用 [shared synchronize]; 读数据 对应的读取数据方式： 1 2 3 4 5 6 7 - (NSString *)readDataFromNSUserDefaults { NSUserDefaults *shared = [[NSUserDefaults alloc] initWithSuiteName:@&quot;group.wangzz&quot;]; NSString *value = [shared valueForKey:@&quot;wangzz&quot;]; return value; } 4.2 通过NSFileManager共享数据NSFileManager在iOS7提供了containerURLForSecurityApplicationGroupIdentifier方法，可以用来实现app group共享数据。 保存数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 - (BOOL)saveTextByNSFileManager { NSError *err = nil; NSURL *containerURL = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:@&quot;group.wangzz&quot;]; containerURL = [containerURL URLByAppendingPathComponent:@&quot;Library/Caches/good&quot;]; NSString *value = _textField.text; BOOL result = [value writeToURL:containerURL atomically:YES encoding:NSUTF8StringEncoding error:&amp;err]; if (!result) { NSLog(@&quot;%@&quot;,err); } else { NSLog(@&quot;save value:%@ success.&quot;,value); } return result; } 读数据 1 2 3 4 5 6 7 8 9 - (NSString *)readTextByNSFileManager { NSError *err = nil; NSURL *containerURL = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:@&quot;group.wangzz&quot;]; containerURL = [containerURL URLByAppendingPathComponent:@&quot;Library/Caches/good&quot;]; NSString *value = [NSString stringWithContentsOfURL:containerURL encoding:NSUTF8StringEncoding error:&amp;err]; return value; } 在这里我试着保存和读取的是字符串数据，但读写SQlite我相信也是没问题的。 数据同步 两个应用共同读取同一份数据，就会引发数据同步问题。WWDC2014的视频中建议使用NSFileCoordination实现普通文件的读写同步，而数据库可以使用CoreData,Sqlite也支持同步。 五、extension和containing app代码共享和数据共享类似，extension和containingapp很自然地会有一些业务逻辑上可以共用的代码，这时可以通过iOS8中刚开放使用的framework实现。苹果在 App ExtensionProgramming Guide 中是这样描述的： In iOS 8.0 and later, you can use an embedded framework to share codebetween your extension and its containing app. For example, if you developimage-processing code that you want both your Photo Editing extension and itscontaining app to share, you can put the code into a framework and embed it inboth targets. 即将framework分别嵌入到extension和containingapp的target中实现代码共享。但这样岂不是需要分别要将framework分别copy到extension和containing app的mainbundle中？ 参考extension和containing app数据共享，我试想能不能将framework只保存一份放在App Groups区域？ 5.1 copy framework到App Groups在app首次启动的时候将framework放到App Groups区域： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 - (BOOL)copyFrameworkFromMainBundleToAppGroup { NSFileManager *manager = [NSFileManager defaultManager]; NSError *err = nil; NSURL *containerURL = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:@&quot;group.wangzz&quot;]; NSString *sorPath = [NSString stringWithFormat:@&quot;%@/Dylib.framework&quot;,[[NSBundle mainBundle] bundlePath]]; NSString *desPath = [NSString stringWithFormat:@&quot;%@/Library/Caches/Dylib.framework&quot;,containerURL.path]; BOOL removeResult = [manager removeItemAtPath:desPath error:&amp;err]; if (!removeResult) { NSLog(@&quot;%@&quot;,err); } else { NSLog(@&quot;remove success.&quot;); } BOOL copyResult = [[NSFileManager defaultManager] copyItemAtPath:sorPath toPath:desPath error:&amp;err]; if (!copyResult) { NSLog(@&quot;%@&quot;,err); } else { NSLog(@&quot;copy success.&quot;); } return copyResult; } 5.2 使用framework：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 - (BOOL)loadFrameworkInAppGroup { NSError *err = nil; NSURL *containerURL = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:@&quot;group.wangzz&quot;]; NSString *desPath = [NSString stringWithFormat:@&quot;%@/Library/Caches/Dylib.framework&quot;,containerURL.path]; NSBundle *bundle = [NSBundle bundleWithPath:desPath]; BOOL result = [bundle loadAndReturnError:&amp;err]; if (result) { Class root = NSClassFromString(@&quot;Person&quot;); if (root) { Person *person = [[root alloc] init]; if (person) { [person run]; } } } else { NSLog(@&quot;%@&quot;,err); } return result; } 经过测试，竟然能够加载成功。 需要说明的是，这里只是说那么用是可以成功加载framework，但还面临不少问题，比如如果用户在启动app之前去使用extension，这时framework还没有copy过去，怎么处理；另外iOS的机制或者苹果的审核是否允许这样使用等。 在一切确定下来之前还是乖乖按文档中的方式使用吧。 六、生命周期extension和普通app的最大区别之一是生命周期。 开始 在用户通过host app点击extension时，系统就会实例化extension应用，这是生命周期的开始。 执行任务 在extension启动以后，开始执行它的使命。 终止 在用户取消任务，或者任务执行结束，或者开启了一个长时后台任务时，系统会将其杀掉。 由此可见，extension就是为了任务而生！ 下图来自官方文档，它将生命周期划分的更详细： 通过打印日志发现， Today 中的 widget 在将 Today 切换到 全部 或者 未读通知时 都会被杀掉。 七、 调试extension和普通app的调试方式差不多，开始调试前先选中extension对应的target，点击run，就会弹出下图所示选择框： 需要选择一个host app，这里选择 Today 。 然后即可和普通app一样调试了，不过我在实际使用过程中，发现有各种奇怪的事情，比如NSLog无法在控制台输出，应该是bug吧。 八、 iOS8应用文件系统发现iOS8的文件系统发生了变化，新的文件系统将可执行文件（即原来的.app文件）从沙盒中移到了另外一个地方，这样感觉更合理。 测试代码 下述代码用于打印App Groups路径、应用的可执行文件路径、对应的Documents路径： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 - (void)logAppPath { //app group路径 NSURL *containerURL = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:@&quot;group.wangzz&quot;]; NSLog(@&quot;app group:\\n%@&quot;,containerURL.path); //打印可执行文件路径 NSLog(@&quot;bundle:\\n%@&quot;,[[NSBundle mainBundle] bundlePath]); //打印documents NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *path = [paths objectAtIndex:0]; NSLog(@&quot;documents:\\n%@&quot;,path); } containing app执行结果 1 2 3 4 5 6 2014-06-23 19:35:03.944 AppExtensionDemo[7471:365131] app group: /private/var/mobile/Containers/Shared/AppGroup/89CCBFB1-CA5E-4C7F-80CB-A3EB9E841816 2014-06-23 19:35:03.946 AppExtensionDemo[7471:365131] bundle: /private/var/mobile/Containers/Bundle/Application/1AC73797-A3BB-4BDE-A647-3D083DA6871A/AppExtensionDemo.app 2014-06-23 19:35:03.948 AppExtensionDemo[7471:365131] documents: /var/mobile/Containers/Data/Application/E5E6E516-0163-4754-9D10-A5F6C33A6261/Documents extension执行结果 1 2 3 4 5 6 Jun 23 19:37:49 autonavis-iPad com.foogry.AppExtensionDemo.TodayExtension[7638] &lt;Warning&gt;: app group: /private/var/mobile/Containers/Shared/AppGroup/89CCBFB1-CA5E-4C7F-80CB-A3EB9E841816 Jun 23 19:37:49 autonavis-iPad com.foogry.AppExtensionDemo.TodayExtension[7638] &lt;Warning&gt;: bundle: /private/var/mobile/Containers/Bundle/Application/596717B7-7CB8-4F53-BCD4-380F34ABD30F/AppExtensionDemo.app/PlugIns/com.foogry.AppExtensionDemo.TodayExtension.appex Jun 23 19:37:49 autonavis-iPad com.foogry.AppExtensionDemo.TodayExtension[7638] &lt;Warning&gt;: documents: /var/mobile/Containers/Data/PluginKitPlugin/57581433-3DBD-4930-971F-78D30C150E8A/Documents 由此可见，不管是extension还是containing app，他们的可执行文件和保存数据的目录都是分开存放的，即所有app的可执行文件都放在一个大目录下，保存数据的目录保存在另一个大目录下，同样，AppGroup放在另一个大目录下。 说明 本文用到的demo已经上传到 github 上。 文中可能有理解有误的地方，还请指出。 参考文档 App Extension Programming Guide Crash Course In iOS 8 Widgets Notification Center Framework Reference iOS 8 Release Notes Entitlement Key Reference 苹果的插件生态系统，开发者的新世界 iOS 8 Extensions: Apple’s Plan for a Powerful App Ecosystem Property List Programming Guide","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"Share Extension调试","date":"2017-02-23T20:59:00.000Z","path":"2017/02/23/Share Extension调试 /","text":"最近添加原生扩展功能，如图： 而在当前Xcode8.2.1中，扩展的NSlog无法显示在Xcode中，最后从Stackoverflow得知，可以打开Mac的 console.app 查看在手机上的打印。 另： - (void)didSelectPost { } 中必须以 [self.extensionContext completeRequestReturningItems:@[] completionHandler:nil]; 结束。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"移除字符串NSString中的特定字符","date":"2017-02-03T22:24:00.000Z","path":"2017/02/03/移除字符串NSString中的特定字符 /","text":"如果要移除NSString ni&#39;hao shi&#39;jie 中的单引号，那么可以使用这条语句： NSString *stringWithoutQuotation = [myString stringByReplacingOccurrencesOfString:@&quot;&apos;&quot; withString:@&quot;&quot;]; 也可以使用这条语句： NSString* noQuotation = [[myString componentsSeparatedByCharactersInSet:@&quot;&apos;&quot;] componentsJoinedByString:@&quot;&quot;];","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"Objective-C中使用extern引用外部全局变量(如：创建全局可变字符串)","date":"2017-02-03T22:13:00.000Z","path":"2017/02/03/Objective-C中使用extern引用外部全局变量(如：创建全局可变字符串)/","text":"使用 extern 可以创建外部文件可以访问的全局变量。这样我们可以让多个类操控同一变量。通过它可以实现全局可变字符串。 extern的使用方法：1. 在需要初始化该变量的文件(如:func.m)中，定义变量 NSMutableString *globalString; (注：需定义在 @interface 和 @implementation 之外)2. 在需要用到这一变量的另一文件中使用语句： extern NSMutableString *globalString; 声明变量，以表明它已在其他文件中定义。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"Effective Objective-C 2.0  编写高质量iOS与OS X代码的52个有效方法","date":"2017-01-11T08:34:08.000Z","path":"2017/01/11/Effective-Objective-C2.0/","text":"一、熟悉Objective-C1.使用消息结构的语言，其运行时执行的代码由运行环境决定，而函数调用型语言，由编译器决定。消息机制的这种方式，叫“动态绑定”（dynamic binding）。对象创建在堆(heap)上，而不是栈(stack) 2.在类的头文件中尽量少引用其他头文件。 a.如果可以，优先使用向前声明forward declaration @class xxxx代替 b.@class xxxx还能避免两个类相互引用的问题——“循环引用 chicken-and-egg situation”，虽然#import xxxx不会像#include xxxx那样导致死循环，但它会导致一个类无法正确编译。 c.有时无法使用向前声明，比如声明某个类遵循一项协议，这种情况，尽量把“协议”的这条声明移至“class-continuation category”中。如果不行，把协议单独放在一个头文件中，然后引入。 3.多用字面量语法， 少用与之等价的方法。 使用字面量创建字符串、数组、字典，可以缩短源代码长度，使其更加简明扼要。通过取下标访问数组或字典元素。字面量中含有nil会抛出异常，更加安全。 a.字面数值(NSNumber) 原本需要使用NSNumber *someNumber = [NSNumber numberWithInt:1];, 而使用字面量只需： NSNumber *intNumber = @1; NSNumber *floatNumber = @2.5f; NSNumber *boolNumber = YES; NSNumber *charNumber = @&#39;a&#39;; int x = 5; float y = 5.12f; NSNumber *number = @{x * y}; b.字面量数组(NSArray) 原本需要使用NSArray *animal = [NSArray arrayWithObjects:@&quot;cat&quot;, @&quot;dog&quot;, @&quot;mouse&quot;, @&quot;badger&quot;, nil];, 而使用字面量只需： NSArray *animal = @[@&quot;cat&quot;, @&quot;dog&quot;, @&quot;mouse&quot;, @&quot;badger&quot;]; 如果数组元素中有nil，使用字面量会抛出异常： id object1 = /* ... */; id object2 = nil; id object3 = /* ... */; NSArray arrayA = [NSArray arrayWithObjects:object1, object2, object3, nil]; NSArray arrayB = @[object1, object2, object3]; 那么arrayA会得到一个仅含object1的数组，因为方法arrayWithObjects会在第一个nil处终止。 而arrayB会抛出异常，所以使用字面量更加安全，可以更快发现错误。 c.字面量字典(NSDictionary) 一般的创建方法:NSDictionary *personData = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;Matt&quot;, @&quot;firstName&quot;, @&quot;Galloway&quot;, @&quot;lastName&quot;, [NSNumber numberWithInt:28], @&quot;age&quot;, nil]; 其顺序是&lt;对象&gt;,&lt;键&gt;，这与通常的顺序相反，我们一般认为是把“键”映射到“对象”，所以此方法不容易读懂。使用字面量就清晰多了： NSDictionary *personData = @{@&quot;firstName&quot; : @&quot;Matt&quot;, @&quot;lastName&quot; : @&quot;Galloway&quot;, @&quot;age&quot; : @28}; 此写法还说明了一点:字典对象和键必须是Objective-C对象，所以不能直接将数字28放入，必须封装在NSNumber实例才行，而是用字面量又很容易做到，只需在数字前加@ 与数组一样，当碰到有nil的情况，也会抛出异常。 d.局限：字符串、数组、字典的自定义子类必须采用“非字面量语法”；字面量创建出的对象是不可变的，若要可变，需要复制一份：NSMutableArray *mutable = [@[@1, @2, @3, @4, @5] mutableCopy];4.多用类型常量(const)，少用#define预处理命令 a.宏定义#define定义的常量不包含数据类型信息，编译器只是做了简单的查找和替换。并且若用#define重复定义了某个常量，编译器也不会发出警告，这使得程序中的这一常量值不一致。 b.实现文件.m用static const定义“只在编译单元内可见的常量”。由于此类常量不在全局变量表中，所以无须为其名称添加前缀。 c.头文件.h中使用extern来声明全局常量，并在与之对应的实现文件中定义常量的值。这种常量出现在全局常量表中，所以通常用与之相关的类名做前缀用于区分。5.用枚举表示状态、选项、状态码 a.枚举的定义：12345enum EOCConnectionState &#123;EOCConnectionStateDisconnected,EOCConnectionStateConnecting,EOCConnectionStateConnected,&#125;; b.枚举的使用：enum EOCConnectionState state = EOCConnectionStateDisconnected; c.每次使用定义新的EOCConnectionState枚举变量时时，都要跟上enum，为了简化，可以使用typedef：123456enum EOCConnectionState &#123;EOCConnectionStateDisconnected,EOCConnectionStateConnecting,EOCConnectionStateConnected,&#125;;typedef enum EOCConnectionState EOCConnectionState; 或12345typedef enum EOCConnectionState &#123;EOCConnectionStateDisconnected,EOCConnectionStateConnecting,EOCConnectionStateConnected,&#125; EOCConnectionState; d.使用：EOCConnectionState state = EOCConnectionStateDisconnected; e.应该用枚举表示状态机的状态、传递给方法的选项、状态码等，给这些值起个易懂的名字。 f.当枚举用来表示传递给方法的选项可以多选时，将枚举各项的值定义为2的幂，以便通过按位或操作将其组合，用按位与判断是否已启用某个选项：if (resizing &amp; UIViewAutoresizingFlexibleWidth) g.使用宏NS_ENUM和NS_OPTIONS来定义枚举，并指明数据类型：1234567891011typedef NS_ENUM(NSUInteger, EOCConnectionState) &#123;EOCConnectionStateDisconnected,EOCConnectionStateConnecting,EOCConnectionStateConnected,&#125;;typedef NS_OPTIONS(NSUInteger, EOCPermittedDirection) &#123;EOCPermittedDirectionUp = 1 &lt;&lt; 0,EOCPermittedDirectionDown = 1 &lt;&lt; 1,EOCPermittedDirectionLeft = 1 &lt;&lt; 2,EOCPermittedDirectionRight = 1 &lt;&lt; 3,&#125;; h.在处理使用了枚举类型的switch语句中不要实现default分支。这样的话，以后添加新的枚举项时，编译器会提醒开发者：switch分支未处理所有枚举项 二、对象，消息，运行时","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"http://ichenwin.github.io/tags/Objective-C/"}]},{"title":"备份 Hexo 源文件至 GitHub","date":"2016-12-31T22:34:08.000Z","path":"2016/12/31/backup-your-blog-to-github/","text":"本文转自：http://www.leyar.me/backup-your-blog-to-github/ 前言这个博客一开始是部署到 GitHub 的，但是每次 Deploy 只是将生成的 html 文件部署进去。根目录文件还是在本机子，这样在换机子之后还得把整个 hexo 目录打包到新电脑，比较麻烦。我前面的操作方式是将真个根目录 push 到同仓库的一个 blog 分支下，当时没有记录操作方法。恰逢自己的生活博客也迁移到了 hexo 上，计划也将他备份到 GitHub，这里将过程在这里记录一下。 操作前提已创建有 GitHub 仓库，并且已使用 hexo-deployer-git 部署到 master 分支。如果不满足请自行 google hexo 部署到 GitHub 的操作方法。 过程首先在官网新建一个仓库，比如我新建的仓库名为ileyar.com 在本地 hexo 根目录下，初始化 git 仓库1git init 创建并切换到名为“hexo” 的分支1git checkout -b hexo 添加 README，并填写相关的说明，此步骤可略过1git add README.md 创建忽略文件 .gitignore1vi .gitignore 按需添加如下内容：12345678.DS_Store Thumbs.dbdb.json *.log.deploy*/node_modules/.npmignorepublic/ 上面最后一行忽略 public 目录，已经被 hexo 插件同步到 master 分支里，因此不需要再同步，deploy 是 hexo 的 git 配置存放目录，也不需要同步。其他内容可选择忽略也可以选择同步。 添加内容到仓库并提交到远程仓库1234git add . # git add -Agit commit -m &quot;first commit&quot;git remote add origin git@github.com:iLeyar/ileyar.com.git # 后面仓库目录改成自己新建的。git push -u origin hexo 写在后面按照以上的步骤就进行了 hexo 源文件的初次备份。以后每次修改了内容之后，都可通过一下几条命令实现同步。 123git add .git commit -m &quot;...&quot; # 双引号内填写更新内容git push origin hexo # 或者 git push 同步要在一台新的机子上写博客时，只需以下几步：1.新建blog文件夹2.在此文件夹下，初始化git仓库：git init3.为本地仓库添加远端仓库：git remote add origin https://github.com/iChenwin/ichenwin.github.io.git4.切换至hexo分支：git checkout -b hexo5.获取hexo分支源文件：git pull origin hexo6.然后就是写博客，并将.md博客文件放至_posts文件夹，然后添加修改到本地仓库：git add .7.提交更改：git commit -m &quot;写了一篇博客&quot;8.推至远端仓库hexo分支：git push origin hexo9.至此，已经完成了博客的撰写并修改了远端仓库的博客源文件，然后使用hexo g和hexo d更新博客就OK啦！ 另外刚在 stackoverflow 上看到一个关于 git add . , git add -u 以及 git add -A 的区别。 git add -A stages ALLgit add . stages new and modified, without deletedgit add -u stages modified and deleted, without new","tags":[{"name":"hexo","slug":"hexo","permalink":"http://ichenwin.github.io/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://ichenwin.github.io/tags/git/"},{"name":"backup","slug":"backup","permalink":"http://ichenwin.github.io/tags/backup/"},{"name":"github","slug":"github","permalink":"http://ichenwin.github.io/tags/github/"}]},{"title":"树莓派WiFi重连","date":"2016-12-24T22:28:00.000Z","path":"2016/12/24/树莓派WiFi重连 /","text":"家里WiFi信号有点弱，当WiFi出错时，树莓派并不会自动去重连。不过我们可以用一个脚本并将它加入crontab定时任务来实现。脚本地址： https://github.com/dweeber/WiFi_Check 脚本内容如下，使用方法在注释中： #!/bin/bash ################################################################## # A Project of TNET Services, Inc # # Title: WiFi_Check # Author: Kevin Reed (Dweeber) # dweeber.dweebs@gmail.com # Project: Raspberry Pi Stuff # # Copyright: Copyright (c) 2012 Kevin Reed &lt;kreed@tnet.com&gt; # https://github.com/dweeber/WiFi_Check # # Purpose: # # Script checks to see if WiFi has a network IP and if not # restart WiFi # # Uses a lock file which prevents the script from running more # than one at a time. If lockfile is old, it removes it # # Instructions: # # o Install where you want to run it from like /usr/local/bin # o chmod 0755 /usr/local/bin/WiFi_Check # o Add to crontab # # Run Every 5 mins - Seems like ever min is over kill unless # this is a very common problem. If once a min change */5 to * # once every 2 mins */5 to */2 ... # # */5 * * * * /usr/local/bin/WiFi_Check # ################################################################## # Settings # Where and what you want to call the Lockfile lockfile=&apos;/var/run/WiFi_Check.pid&apos; # Which Interface do you want to check/fix wlan=&apos;wlan0&apos; ################################################################## echo echo &quot;Starting WiFi check for $wlan&quot; date echo # Check to see if there is a lock file if [ -e $lockfile ]; then # A lockfile exists... Lets check to see if it is still valid pid=`cat $lockfile` if kill -0 &amp;&gt;1 &gt; /dev/null $pid; then # Still Valid... lets let it be... #echo &quot;Process still running, Lockfile valid&quot; exit 1 else # Old Lockfile, Remove it #echo &quot;Old lockfile, Removing Lockfile&quot; rm $lockfile fi fi # If we get here, set a lock file using our current PID# #echo &quot;Setting Lockfile&quot; echo $$ &gt; $lockfile # We can perform check echo &quot;Performing Network check for $wlan&quot; if ifconfig $wlan | grep -q &quot;inet addr:&quot; ; then echo &quot;Network is Okay&quot; else echo &quot;Network connection down! Attempting reconnection.&quot; ifdown $wlan sleep 5 ifup --force $wlan ifconfig $wlan | grep &quot;inet addr&quot; fi echo echo &quot;Current Setting:&quot; ifconfig $wlan | grep &quot;inet addr:&quot; echo # Check is complete, Remove Lock file and exit #echo &quot;process is complete, removing lockfile&quot; rm $lockfile exit 0 ################################################################## # End of Script ##################################################################","tags":[{"name":"树莓派","slug":"树莓派","permalink":"http://ichenwin.github.io/tags/树莓派/"}]},{"title":"Programming with Objective-C笔记","date":"2016-12-24T22:23:00.000Z","path":"2016/12/24/Programming with Objective-C笔记 /","text":"一、前言 对象，app是许多种对象构成的。An App Is Built from a Network of Objects 类别，用于扩展一个现有类，也可用于隐藏私有方法。Categories Extend Existing Classes 协议，定义了类之间的消息机制，delegate。Protocols Define Messaging Contracts 值和数组常用Objective-C对象表示，如：NSString用于表示字符串，NSNumber表示各种数字，NSValue用来表示C语言中的结构。而常用数组有：NSArray、 NSSet、 和 NSDictionary。Values and Collections Are Often Represented as Objective-C Objects 代码块用于简化日常操作，比如：数组的枚举，查找，校验（collection enumeration, sorting and testing）。它类似于其他语言的“闭包”，也可用于一些同步和异步操作（如：Grand Central Dispatch (GCD)技术）。Blocks Simplify Common Tasks NSError 可以捕获运行时错误，如：存储空间不足、无法连接网络等。Error Objects Are Used for Runtime Problems","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"树莓派crontab定时任务","date":"2016-12-23T22:48:00.000Z","path":"2016/12/23/树莓派crontab定时任务 /","text":"1. crontab编辑命令： crontab -e # min hour day month dayofweek cmd */3 * * * * /usr/share/nginx/www/pi-pull.sh （其中 */3 表示每隔3分钟）2. 树莓派中crontab命令： cron start/stop/restart/status","tags":[{"name":"树莓派","slug":"树莓派","permalink":"http://ichenwin.github.io/tags/树莓派/"}]},{"title":"Python文本替换（剔除、截取、添加字符串）","date":"2016-12-20T17:36:00.000Z","path":"2016/12/20/Python文本替换（剔除、截取、添加字符串） /","text":"1. 删除字符串中的数字要将以下文件中的数字和描述删除，只留下单词，并且转存为Objective-C的数组格式，第一步，先将数字全部剔除： #!/usr/bin/python # -*- coding: UTF-8 -*- import re file = open(&quot;words.txt&quot;) output = open(&quot;out.txt&quot;, &apos;wb&apos;) for line in file.readlines(): #删除字母、‘,’、‘()’、‘tab’以外的字符，即数字 newline = filter(lambda ch: ch in &apos; abcdefghijklmnopqrstuvwxyz,() &apos;, line) print newline output.write(&apos;@&quot;&apos; + newline + &apos;\\n&apos;) file.close() output.close() 处理完之后，得到一下文本文件：2. 剔除单词后边所有字符串 #!/usr/bin/python # -*- coding: UTF-8 -*- file = open(&quot;out.txt&quot;, &apos;r&apos;) output = open(&quot;dict.txt&quot;, &quot;wb&quot;) for line in file.readlines(): #查找单词后头的tab，记录偏移量 pos = line.find(&quot; &quot;, 0) print line[0:pos] + &apos;&quot;, &apos; #将tab之前的字符串，加上引号、逗号和换行符，写入数出文件 output.write(line[0:pos] + &apos;&quot;, \\n&apos;) file.close() out.close() 得到最终我们需要的 Objective-C 单词数组的文本形式：","tags":[{"name":"Python","slug":"Python","permalink":"http://ichenwin.github.io/tags/Python/"}]},{"title":"树莓派DNS设置","date":"2016-12-19T22:43:00.000Z","path":"2016/12/19/树莓派DNS设置 /","text":"一早起来，发现花生壳掉线了， ping www.baidu.com 也得到 Unkonwn host 的报错。试着访问网关 ping 192.168.1.1 ，没问题。然后检查DNS配置，网上说配置 /etc/resolv.conf，然而发现配置这个文件，重启后，DNS会失效。DNS配置还是应该在 /etc/network/interfaces 里完成： auto lo wlan0 wlan1 iface lo inet loopback auto eth0 allow-hotplug eth0 iface eth0 inet dhcp allow-hotplug wlan0 wlan1 #iface wlan0 inet dhcp iface wlan0 inet static address 192.168.1.112 netmask 255.255.255.0 gateway 192.168.1.1 wpa-conf /etc/wpa_supplicant/wpa_supplicant.conf iface wlan1 inet manual wpa-conf /etc/wpa_supplicant/wpa_supplicant.conf #DNS配置 dns-nameservers 8.8.8.8 223.5.5.5","tags":[{"name":"树莓派","slug":"树莓派","permalink":"http://ichenwin.github.io/tags/树莓派/"}]},{"title":"树莓派无线网络配置","date":"2016-12-18T12:12:00.000Z","path":"2016/12/18/树莓派无线网络配置 /","text":"原文： 树莓派连接WiFi (需科学上网) 1. 无线连接这里介绍一种嵌入式业界常用的WiFi连接方法，可完全应用于树莓派，实现WiFi的方便、稳定连接：1. 同时保存多个WiFi用户名和密码2. 可设置连接优先级，多WiFi环境下优先连接指定WiFi3. 避免重启系统，也无需重启任何服务4. 断开自动重连 方法步骤1. 修改网络配置/etc/network/interfaces 用命令行文本编辑器 nano 打开 /etc/network/interfaces 文件，按如下方式修改： 如果你从没有编辑过 /etc/network/interfaces文件，那它其中几行看起来是这个样子： iface wlan0 inet manual wpa-roam /etc/wpa_supplicant/wpa_supplicant.conf 你要做的是把上述两行替换成 iface wlan0 inet dhcp wpa_conf /etc/wpa_supplicant/wpa_supplicant.conf 这样就行了 如果你以前按照其他文章的方法，把 /etc/network/interfaces改写成下面的样子： iface wlan0 inet dhcp wpa-ssid &quot;WiFi-name&quot; wpa-psk &quot;WiFi-password&quot; 那么你要做的同样是，把上述三行替换成 iface wlan0 inet dhcp wpa_conf /etc/wpa_supplicant/wpa_supplicant.conf 即可。 建议，若你不使用树莓派的有线网口连接网络的话，最好把 /etc/network/interfaces 文件第一行（也可能不在第一行）中 auto loeth0 wlan0 的 eth0删掉。因为它会导致树莓派开机时等待有线网卡动态分配IP，但实际上你的有线网口并没有连接到路由器，这里会让内核等待更长的时间，从而拖慢开机速度。 尚不熟悉nano的用法，戳 nano简明使用指南笔者的 /etc/network/interfaces 配置如下：2. 配置 /etc/wpa_supplicant/wpa_supplicant.conf除 /etc/network/interfaces 之外，你还需要修改 /etc/wpa_supplicant/wpa_supplicant.conf 。所有的WiFi连接配置都在这里了。 打开 /etc/wpa_supplicant/wpa_supplicant.conf 照着下面的样子添加（请不要删除原先就已经存在的任何行）： # 最常用的配置。WPA-PSK 加密方式。 network={ ssid=&quot;WiFi-name1&quot; psk=&quot;WiFi-password1&quot; priority=5 } network={ ssid=&quot;WiFi-name2&quot; psk=&quot;WiFi-password2&quot; priority=4 } priority 是指连接优先级，数字越大优先级越高（不可以是负数）。 按照自己的实际情况，修改这个文件。 例如，你家中有3个WiFi，分别为WiFi-A、WiFi-B和WiFi-C。你希望树莓派的连接优先级为WiFi-A&gt;WiFi-B&gt;WiFi-C，则整个配置文件看起来像这样： ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev update_config=1 network={ ssid=&quot;WiFi-A&quot; psk=&quot;12345678&quot; priority=5 } network={ ssid=&quot;WiFi-B&quot; psk=&quot;12345678&quot; priority=4 } network={ ssid=&quot;WiFi-C&quot; psk=&quot;12345678&quot; priority=3 } 笔者的 /etc/wpa_supplicant/wpa_supplicant.conf 配置如下：3. 开始连接WiFi修改好 /etc/network/interfaces 之后，无论是连接还是断开WiFi，都变得简洁无比。 连接WiFi 在命令行下输入sudo ifup wlan0这条命令的意思是，启用（up）wlan0端口，即寻找可用WiFi并尝试连接。 命令会在屏幕上打印几行字符，未输出错误信息的话，就意味着WiFi连接成功了：你可以用 iwconfig 命令或 ifconfig 命令检查一下WiFi连接：4. 断开WiFi在命令行下输入sudo ifdown wlan0这条命令的意思是，关闭（down）wlan0端口，即断开已连接的WiFi。千万不要在网络连接ssh时候执行这条命令，它会直接断开你的ssh连接","tags":[{"name":"树莓派","slug":"树莓派","permalink":"http://ichenwin.github.io/tags/树莓派/"}]},{"title":"Python批处理删除和重命名文件夹","date":"2016-12-11T23:11:00.000Z","path":"2016/12/11/Python批处理删除和重命名文件夹 /","text":"1. 删除当前目录下不含有指定文件类型的文件夹#!/usr/bin/python # -*- coding: UTF-8 -*- import sys import os import shutil pwd = os.getcwd() L = os.listdir(&quot;.&quot;) f = open(&quot;out.txt&quot;, &quot;w&quot;) for dirname in L: if os.path.isdir(dirname): print(&quot;dir name:&quot; + dirname) os.chdir(dirname) files = os.listdir(&quot;.&quot;) filePreName = &quot;filename&quot; extName = &quot;ext name&quot; delete = True for filename in files: print filename print &gt;&gt; f, &quot;%s&quot; % filename filePreName, extName = os.path.splitext(filename) if extName.lower() == &quot;.zip&quot; or extName.lower() == &quot;.jpg&quot; or extName.lower() == &quot;.doc&quot; or extName.lower() == &quot;.pdf&quot; or extName.lower() == &quot;.xls&quot; or extName.lower() == &quot;.gif&quot; or extName.lower() == &quot;.ppt&quot; or extName.lower() == &quot;.iso&quot; or extName.lower() == &quot;.mp3&quot; or extName.lower() == &quot;.wav&quot; or extName.lower() == &quot;.rar&quot; or extName.lower() == &quot;.mkv&quot; or extName.lower() == &quot;.mp4&quot; or extName.lower() == &quot;.bmp&quot; or extName.lower() == &quot;.exe&quot; or extName.lower() == &quot;.docx&quot; or extName.lower() == &quot;.png&quot; or extName.lower() == &quot;.txt&quot;: delete = False os.chdir(&quot;..&quot;) if delete: shutil.rmtree(dirname) print dirname + &quot; deleted!!!&quot; print &gt;&gt; f, &quot;%s&quot; % dirname + &quot; deleted!!!&quot; print &quot;--------------------------&quot; print &gt;&gt; f, &quot;%s&quot; % &quot;--------------------------&quot; f.close() 2. 遍历目录下每个子文件夹，并列出子文件夹下的文件，默认删除含指定类型的文件夹，不包含指定文件类型的，则提示，是否删除或者重命名文件夹#!/usr/bin/python # -*- coding: UTF-8 -*- import sys import os import shutil pwd = os.getcwd() L = os.listdir(&quot;.&quot;) f = open(&quot;out.txt&quot;, &quot;w&quot;) for dirname in L: if os.path.isdir(dirname): print(&quot;dir name:&quot; + dirname) os.chdir(dirname) files = os.listdir(&quot;.&quot;) i = 0 filePreName = &quot;filename&quot; extName = &quot;ext name&quot; for filename in files: print filename print &gt;&gt; f, &quot;%s&quot; % filename filePreName, extName = os.path.splitext(filename) if extName == &quot;.java&quot; or extName == &quot;.js&quot; or extName == &quot;.yml&quot; or extName == &quot;.ejs&quot; or extName == &quot;.svg&quot; or extName == &quot;.sample&quot; or extName == &quot;.styl&quot; or extName == &quot;.class&quot; or extName == &quot;.xml&quot; or extName == &quot;.html&quot; or extName == &quot;.so&quot; or extName == &quot;.OPA&quot; or extName == &quot;.pig&quot; or extName == &quot;.obj&quot; or extName == &quot;.sdb&quot; or extName == &quot;.dll&quot;: i += 1 os.chdir(&quot;..&quot;) #整理杂乱的硬盘时，包含这些文件类型的无关文件夹直接删除 if i &gt;= 3 or filePreName == &quot;HEAD&quot; or filePreName == &quot;master&quot; or extName == &quot;&quot; or (filePreName == &quot;index&quot; and extName == &quot;.html&quot;) or extName == &quot;.java&quot; or extName == &quot;.pyc&quot; or extName == &quot;.py&quot; or extName == &quot;.html&quot; or extName == &quot;.HTM&quot; or extName == &quot;.ini&quot; or extName == &quot;.css&quot; or extName == &quot;.so&quot; or extName == &quot;.xml&quot; or extName == &quot;.bin&quot;: shutil.rmtree(dirname) print(dirname + &quot; deleted!!!&quot;) print &quot;--------------------------&quot; continue deleteOrNot = raw_input(&quot;delete &quot; + dirname + &quot;?(y/n)&quot;) #除了无关文件夹，其余由“我”决定是删除还是直径重命名文件夹 if deleteOrNot == &apos;y&apos;: shutil.rmtree(dirname) print dirname + &quot; deleted!!!&quot; print &gt;&gt; f, &quot;%s&quot; % dirname + &quot; deleted!!!&quot; else: if deleteOrNot == &quot;&quot;: print &quot;no change&quot; + dirname else: os.rename(dirname, deleteOrNot) print &quot;--------------------------&quot; print &gt;&gt; f, &quot;%s&quot; % &quot;--------------------------&quot; f.close() 3. 使用子文件夹中第一个文件的文件名作为该子文件夹的名字#!/usr/bin/python # -*- coding: UTF-8 -*- import sys import os import shutil import random pwd = os.getcwd() L = os.listdir(&quot;.&quot;) f = open(&quot;rename.txt&quot;, &quot;w&quot;) for dirname in L: if os.path.isdir(dirname): os.chdir(dirname) files = os.listdir(&quot;.&quot;) filePreName = &quot;filename&quot; extName = &quot;ext name&quot; filename = files[0] filePreName, extName = os.path.splitext(filename) os.chdir(&quot;..&quot;) os.rename(dirname, filePreName + str(random.randint(1,999))) print dirname + &quot;-&gt;&quot; + filePreName + str(random.randint(1,999)) print &gt;&gt; f, &quot;%s&quot; % dirname + &quot;-&gt;&quot; + filePreName + str(random.randint(1,999)) f.close()","tags":[{"name":"Python","slug":"Python","permalink":"http://ichenwin.github.io/tags/Python/"}]},{"title":"Mac OS X 启用 Web 服务器","date":"2016-12-09T15:47:00.000Z","path":"2016/12/09/Mac OS X 启用 Web 服务器 /","text":"文／小白不是总（简书作者）原文链接： http://www.jianshu.com/p/d006a34a343f 著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。 我们经常性的需要使用局域网搭建 Web 服务器测试环境，如部署局域网无线安装企业应用等，Mac OS X 自带了 Apache 和 PHP环境，我们只需要简单的启动它就行了。 1. 启动 Apache 查看 Apache 版本打开终端，输入 httpd -v 可以查看 Apache 版本信息。 $ httpd -v Server version: Apache/2.4.16 (Unix) Server built: Aug 22 2015 16:51:57 $ 启动 Apache在终端输入 sudo apachectl start 即可启动 Apache。启动后，在浏览器中输入 http://127.0.0.1 或 http://localhost 如果看到 It Works! 页面 那么 Apache 就启动成功了，站点的根目录为系统级根目录 /Library/WebServer/Documents。 启动后，你可以通过编辑 /etc/apache2/httpd.conf 文件来修改 Apache 配置。 停止 Apache：sudo apachectl stop 重启 Apache：sudo apachectl restart创建用户级根目录我们也可以创建用户级根目录，更方便管理和操作。 在用户目录下创建 Sites 目录，cd; mkdir Sites; touch Sites/.localized，旧的 Mac系统中如果该目录已存在，则略过。cd /etc/apache2/users 检查目录下是否存在 username.conf 文件，username 为当前用户名，如果没有则创建一个sudo touch username.conf，并修改文件权限 sudo chmod 644 username.conf。创建之后，打开 username.conf 文件，sudo vi username.conf 将下面的配置信息写入文件，username 依然为当前用户名： &lt;Directory &quot;/Users/username/Sites/&quot;&gt; Options Indexes MultiViews FollowSymLinks AllowOverride All Order allow,deny Allow from all Require all granted &lt;/Directory&gt; 编辑 /etc/apache2/httpd.conf 文件，找到下列代码，并将前面的注释符号 # 删除： Include /private/etc/apache2/extra/httpd-userdir.conf LoadModule userdir_module libexec/apache2/mod_userdir.so 编辑 /etc/apache2/extra/httpd-userdir.conf 文件，找到下列代码，并将前面的注释符号 # 删除： Include /private/etc/apache2/users/*.conf 重启 Apache：sudo apachectl restart 在浏览器中输入 http://127.0.0.1/~username 或 http://localhost/~username ，即可测试用户目录是否工作。 2. 启动 PHP Mac OS X 也默认集成了 PHP 环境，如果测试需要用到 PHP 环境，可以通过配置手动开启。 编辑 /etc/apache2/httpd.conf 文件，找到 LoadModule php5_modulelibexec/apache2/libphp5.so 并删除行前的注释符号 #。重启 Apache：sudo apachectl restart。现在 PHP 应该已经可以工作了，在页面中嵌入 $ cd /etc/apache2/ $ sudo mkdir ssl $ cd ssl 创建主机密钥 $ sudo ssh-keygen -f local.server.com.key Generating public/private rsa key pair. Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in local.server.com.key. Your public key has been saved in local.server.com.key.pub. The key fingerprint is: SHA256:bNX90ww2g2GCh38Q/h68JnazkZYtnbkMEb1G5E51QWw root@XuCreamandeiMac.local The key&apos;s randomart image is: +---[RSA 2048]----+ | oo.o +o+| | o.o+ B E.| | oo.+ % | | . ..o.* B.| | S .= +.+| | . . X o.| | o &amp; = | | . = B . | | . o | +----[SHA256]-----+ $ 这里会被要求提供一个密码用于主机密钥，可以选择任何的密码或直接留空。 也可以使用下面的命令创建密钥： $ sudo openssl genrsa -out local.server.com.key 2048 Generating RSA private key, 2048 bit long modulus ....+++ ....+++ e is 65537 (0x10001) $ 创建签署申请 $ sudo openssl req -new -key local.server.com.key -out local.server.com.csr You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter &apos;.&apos;, the field will be left blank. ----- Country Name (2 letter code) [AU]: State or Province Name (full name) [Some-State]: Locality Name (eg, city) []: Organization Name (eg, company) [Internet Widgits Pty Ltd]: Organizational Unit Name (eg, section) []: Common Name (e.g. server FQDN or YOUR name) []:local.server.com Email Address []: Please enter the following &apos;extra&apos; attributes to be sent with your certificate request A challenge password []: An optional company name []: $ 系统会提示输入各项信息，由于这是自签名的证书，除了 Common Name (e.g. server FQDN or YOUR name) []:FQDN（ fully qualified domain name）必须是服务器域名或 IP 外，其他都不重要，可以随意填写或一路回车，这里作为测试使用local.server.com。 创建SSL证书在生产环境中，我们需要提交证书申请（CSR）文件给证书颁发机构，由证书颁发机构提供SSL证书。 $ sudo openssl x509 -req -days 365 -in local.server.com.csr -signkey local.server.com.key -out local.server.com.crt Signature ok subject=/C=AU/ST=Some-State/O=Internet Widgits Pty Ltd/CN=local.server.com Getting Private key $ 我们也可以直接通过以下的命令创建证书： $ sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout local.server.com.key -out local.server.com.crt 创建NOPASS密钥为了配置 Apache，我们需要创建一个 NOPASS 密钥。 $ sudo openssl rsa -in local.server.com.key -out local.server.com.nopass.key OK，我们看下SSL目录下面的文件，这些文件将在后面被用到： $ ls -l -rw-r--r-- 1 root wheel 1180 10 22 13:08 local.server.com.crt -rw-r--r-- 1 root wheel 993 10 22 11:58 local.server.com.csr -rw------- 1 root wheel 1679 10 22 11:44 local.server.com.key -rw-r--r-- 1 root wheel 408 10 22 11:44 local.server.com.key.pub -rw-r--r-- 1 root wheel 1679 10 22 13:19 local.server.com.nopass.key 配置 SSL加载 mod_ssl.so，编辑 /etc/apache2/httpd.conf 文件，删除下列代码前的注释符号 #： LoadModule ssl_module libexec/apache2/mod_ssl.so 包含 httpd-ssl.conf 文件，编辑 /etc/apache2/httpd.conf 文件，删除下列代码前的注释符号 #： Include /private/etc/apache2/extra/httpd-ssl.conf 添加 到 httpd-ssl.conf，编辑 /etc/apache2/extra/httpd-ssl.conf 文件：httpd-ssl.conf 中已经有一条 记录，我们将其注释掉，新建一条： &lt;VirtualHost *:443&gt; #General setup for the virtual host DocumentRoot &quot;/Library/WebServer/Documents&quot; ServerName local.server.com #SSL Engine Switch: SSLEngine on #Server Certificate: SSLCertificateFile &quot;/etc/apache2/ssl/local.server.com.crt&quot; #Server Private Key: SSLCertificateKeyFile &quot;/etc/apache2/ssl/local.server.com.key&quot; #SSL Engine Options: &lt;FilesMatch &quot;\\.(cgi|shtml|phtml|php)$&quot;&gt; SSLOptions +StdEnvVars &lt;/FilesMatch&gt; &lt;Directory &quot;/Library/WebServer/CGI-Executables&quot;&gt; SSLOptions +StdEnvVars &lt;/Directory&gt; &lt;/VirtualHost&gt; 为了能够使用 URL 访问服务器，我们需要配置HOST，sudo vi /etc/hosts，添加 127.0.0.1 local.server.com 检查配置文件并重启 Apache命令行输入 $ sudo apachectl -t，提示： AH00526: Syntax error on line 92 of /private/etc/apache2/extra/httpd-ssl.conf: SSLSessionCache: &apos;shmcb&apos; session cache not supported (known names: ). Maybe you need to load the appropriate socache module (mod_socache_shmcb?). 根据提示，编辑 /etc/apache2/httpd.conf 文件，删除下列这些代码前的注释符号 # LoadModule socache_shmcb_module libexec/apache2/mod_socache_shmcb.so 再次测试，显示 Syntax OK： $ sudo apachectl -t Syntax OK 说明测试通过，重启 Apache： $ sudo apachectl restart 此时，就可以使用 HTTPS 访问本地服务了，在浏览器中输入 https://local.server.com/ 检查。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"单指移动光标手势，双指修改文本选区手势","date":"2016-12-07T14:35:00.000Z","path":"2016/12/07/单指移动光标手势，双指修改文本选区手势 /","text":"UIView 通过实现 UITextInput 协议，实现单指移动光标手势，双指修改文本选区手势。分别使用了 UIPanGestureRecognizer 和 UIPinchGestureRecognizer 手势。 #import &quot;ViewController.h&quot; #import &quot;JSWebView.h&quot; #import &quot;UIView+Constriant.h&quot; #import “JSInputView.h” #import &quot;UIResponder+FirstResponder.h&quot; #import &quot;NSObject+SetFrame.h&quot; #import &quot;WebViewJavascriptBridge.h&quot; @interface ViewController () &lt;UIWebViewDelegate&gt; @property (nonatomic, strong) JSWebView *webView; @property (nonatomic, strong) NSLayoutConstraint *bottomConstraint; //@property WebViewJavascriptBridge* bridge; @property (nonatomic, assign) CGPoint lastPoint; @property (nonatomic, assign) CGPoint startPoint0; @property (nonatomic, assign) CGPoint startPoint1; @property (nonatomic, assign) CGRect lastRect0; @property (nonatomic, assign) CGRect lastRect1; @property (nonatomic, assign) CGRect startRect0; @property (nonatomic, assign) CGRect startRect1; @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; /*……*/ //单指移动光标手势 UIPanGestureRecognizer *singleFingerPanRecognizer = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(singleFingerMoveCursor:)]; singleFingerPanRecognizer.maximumNumberOfTouches = 1; [self.webView.keyboard addGestureRecognizer:singleFingerPanRecognizer]; //双指选择选区手势 UIPinchGestureRecognizer *pinchGesture = [[UIPinchGestureRecognizer alloc] initWithTarget:self action:@selector(pinchSelect:)]; [self.webView.keyboard addGestureRecognizer:pinchGesture]; self.lastRect0 = CGRectMake(0, 0, 1, 19); self.lastRect1 = CGRectMake(0, 0, 1, 19); self.startPoint0 = CGPointMake(0, 0); self.startPoint1 = CGPointMake(0, 0); self.lastPoint = CGPointMake(0, 0); [self loadWeb]; } #pragma mark - keyboard gesture //单个手指移动光标 - (void)singleFingerMoveCursor: (UIPanGestureRecognizer *)sender { UIResponder &lt;UITextInput&gt;*textInput = [UIResponder currentFirstResponder]; if (sender.state == UIGestureRecognizerStateBegan) { self.lastPoint = CGPointMake(0, 0); CGPoint cursorPoint = [textInput caretRectForPosition:textInput.selectedTextRange.start].origin; self.lastRect0 = CGRectMake(cursorPoint.x, cursorPoint.y, 20, 20); } else if (sender.state == UIGestureRecognizerStateChanged) { // NSString *webString = [self.webView stringByEvaluatingJavaScriptFromString:@&quot;document.body.innerText&quot;]; CGRect newFrame = CGRectMake(self.lastRect0.origin.x + [sender translationInView:self.webView.keyboard].x - self.lastPoint.x, self.lastRect0.origin.y + [sender translationInView:self.webView.keyboard].y - self.lastPoint.y, self.lastRect0.size.width, self.lastRect0.size.height); CGPoint cursorPoint; if ([sender translationInView:self.webView.keyboard].y &gt; 0) { cursorPoint = CGPointMake(newFrame.origin.x, newFrame.origin.y); } else if ([sender translationInView:self.webView.keyboard].y &lt; 0) { cursorPoint = CGPointMake(newFrame.origin.x, newFrame.origin.y + newFrame.size.height); } else { cursorPoint = CGPointMake(newFrame.origin.x, newFrame.origin.y + newFrame.size.height / 2); } UITextPosition *pos = [textInput closestPositionToPoint:cursorPoint]; UITextRange *textRange = [textInput textRangeFromPosition:pos toPosition:pos]; textInput.selectedTextRange = textRange; self.lastRect0 = newFrame; self.lastPoint = CGPointMake([sender translationInView:self.webView.keyboard].x, [sender translationInView:self.webView.keyboard].y); } } static bool isReverse; //左右手指是否和locationOfTouch:检测结果相反 //双指移动选择文字手势 - (void)pinchSelect:(UIPinchGestureRecognizer *)sender { UIResponder &lt;UITextInput&gt;*textInput = [UIResponder currentFirstResponder]; if (sender.state == UIGestureRecognizerStateBegan) { self.startPoint0 = [sender locationOfTouch:0 inView:self.webView.keyboard]; self.startPoint1 = [sender locationOfTouch:1 inView:self.webView.keyboard]; isReverse = false; if (self.startPoint0.x &gt; self.startPoint1.x) { //左右手指相反 CGPoint temp; temp = self.startPoint0; self.startPoint0 = self.startPoint1; self.startPoint1 = temp; isReverse = true; } if (textInput.selectedTextRange.isEmpty){ //是否有选区 self.startRect0 = [textInput caretRectForPosition:textInput.selectedTextRange.start]; self.startRect1 = [textInput caretRectForPosition:textInput.selectedTextRange.start]; } else { self.startRect0 = [textInput caretRectForPosition:textInput.selectedTextRange.start]; self.startRect1 = [textInput caretRectForPosition:textInput.selectedTextRange.end]; } self.lastRect0 = self.startRect0; self.lastRect1 = self.startRect1; } else if (sender.state == UIGestureRecognizerStateChanged) { if ([sender numberOfTouches] == 2) { float deltaX; float deltaY; //左边手指移动距离 if (isReverse) { deltaX = [sender locationOfTouch:1 inView:self.webView.keyboard].x - self.startPoint0.x; deltaY = [sender locationOfTouch:1 inView:self.webView.keyboard].y - self.startPoint0.y; } else { deltaX = [sender locationOfTouch:0 inView:self.webView.keyboard].x - self.startPoint0.x; deltaY = [sender locationOfTouch:0 inView:self.webView.keyboard].y - self.startPoint0.y; } self.lastRect0 = CGRectMake(self.startRect0.origin.x, self.startRect0.origin.y, self.startRect0.size.width, self.startRect0.size.height); if (deltaY &gt; 0) { self.lastRect0 = [self frame:_lastRect0 withPoint:CGPointMake(self.lastRect0.origin.x + deltaX, self.lastRect0.origin.y + deltaY)];//CGRectMake(self.lastRect0.origin.x + deltaX, self.lastRect0.origin.y + deltaY, 20, 20); } else if (deltaY &lt; 0) { self.lastRect0 = [self frame:_lastRect0 withPoint:CGPointMake(self.lastRect0.origin.x + deltaX, self.lastRect0.origin.y + deltaY + self.lastRect0.size.height * 0.9)]; } else { self.lastRect0 = [self frame:_lastRect0 withPoint:CGPointMake(self.lastRect0.origin.x + deltaX, self.lastRect0.origin.y + deltaY + self.lastRect0.size.height * 0.5)]; } //右边手指移动 if (isReverse) { deltaX = [sender locationOfTouch:0 inView:self.webView.keyboard].x - self.startPoint1.x; deltaY = [sender locationOfTouch:0 inView:self.webView.keyboard].y - self.startPoint1.y; } else { deltaX = [sender locationOfTouch:1 inView:self.webView.keyboard].x - self.startPoint1.x; deltaY = [sender locationOfTouch:1 inView:self.webView.keyboard].y - self.startPoint1.y; } self.lastRect1 = [self frame:_lastRect1 withPoint:CGPointMake(self.startRect1.origin.x, self.startRect1.origin.y)]; if (deltaY &gt; 0) { self.lastRect1 = [self frame:_lastRect1 withPoint:CGPointMake(self.lastRect1.origin.x + deltaX, self.lastRect1.origin.y + deltaY)];; } else if (deltaY &lt; 0) { self.lastRect1 = [self frame:_lastRect1 withPoint:CGPointMake(self.lastRect1.origin.x + deltaX, self.lastRect1.origin.y + deltaY + self.lastRect1.size.height * 0.9)];; } else { self.lastRect1 = [self frame:_lastRect1 withPoint:CGPointMake(self.lastRect1.origin.x + deltaX, self.lastRect1.origin.y + deltaY + self.lastRect1.size.height * 0.5)];; } UITextPosition *textPoint0 = [textInput closestPositionToPoint:self.lastRect0.origin]; UITextPosition *textPoint1 = [textInput closestPositionToPoint:self.lastRect1.origin]; textInput.selectedTextRange = [textInput textRangeFromPosition:textPoint0 toPosition:textPoint1]; } } }","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"NSDate和NSString相互转换","date":"2016-11-09T23:09:00.000Z","path":"2016/11/09/NSDate和NSString相互转换 /","text":"NSDate到NSString的转换： //获取系统当前时间 NSDate *currentDate = [NSDate date]; //用于格式化NSDate对象 NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init]; //设置格式：zzz表示时区 [dateFormatter setDateFormat:@”yyyy-MM-dd HH:mm:ss zzz”]; //NSDate转NSString NSString *currentDateString = [dateFormatter stringFromDate:currentDate]; //输出currentDateString NSLog(@”%@”,currentDateString); NSString到NSDate的转换： //需要转换的字符串 NSString *dateString = @&quot;2015-06-26 08:08:08&quot;; //设置转换格式 NSDateFormatter *formatter = [[NSDateFormatter alloc] init] ; [formatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;]; //NSString转NSDate NSDate *date=[formatter dateFromString:dateString]; 刚刚在线 上的介绍： http://www.superqq.com/","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"AFNetworking等待网络请求，继续同步操作","date":"2016-11-09T23:04:00.000Z","path":"2016/11/09/AFNetworking等待网络请求，继续同步操作 /","text":"在发出网络请求后，需要拿到网络返回的数据才能继续后续操作，这时可以用 dispatch_semaphore_wait() - (id)sendForUrl:(NSURL *)url { AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager]; manager.completionQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); __block id response; [manager GET:url.absoluteString parameters:nil success: ^(AFHTTPRequestOperation *operation, id responseObject) { response = responseObject; NSLog(@&quot;JSON: %@&quot;, responseObject); dispatch_semaphore_signal(semaphore); } failure: ^(AFHTTPRequestOperation *operation, NSError *error) { NSLog(@&quot;Error: %@&quot;, error); dispatch_semaphore_signal(semaphore); }]; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); return response; } 栈溢出上的讨论： StackOverFlow","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"UITableViewCell左滑多选项","date":"2016-11-09T22:58:00.000Z","path":"2016/11/09/UITableViewCell左滑多选项 /","text":"- (NSArray&lt;UITableViewRowAction *&gt; *)tableView:(UITableView *)tableView editActionsForRowAtIndexPath:(NSIndexPath *)indexPath { UITableViewRowAction *likeAction = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleNormal title:@&quot;喜欢&quot; handler:^(UITableViewRowAction * _Nonnull action, NSIndexPath * _Nonnull indexPath) { // 实现相关的逻辑代码 // ... // 在最后希望cell可以自动回到默认状态，所以需要退出编辑模式 tableView.editing = NO; }]; UITableViewRowAction *deleteAction = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleDefault title:@&quot;删除&quot; handler:^(UITableViewRowAction * _Nonnull action, NSIndexPath * _Nonnull indexPath) { // 首先改变model [self.books removeObjectAtIndex:indexPath.row]; // 接着刷新view [self.tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationAutomatic]; // 不需要主动退出编辑模式，上面更新view的操作完成后就会自动退出编辑模式 }]; return @[deleteAction, likeAction]; }","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"ViewController跳转后导航栏会发黑","date":"2016-11-09T22:33:00.000Z","path":"2016/11/09/ViewController跳转后导航栏会发黑 /","text":"视图控制器之间跳转，在加载新视图控制器时，导航栏底色会闪一下，是黑色一闪而过。可以通过：self.navigationController.view.backgroundColor = [UIColor whiteColor];或self.navigationController.navigationBar.translucent = NO;解决。 栈溢出的讨论： stackoverflow","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"添加和移除子视图控制器（child ViewController）","date":"2016-11-08T11:30:00.000Z","path":"2016/11/08/添加和移除子视图控制器（child ViewController） /","text":"// add child viewController UIViewController* controller = [self.storyboard instantiateViewControllerWithIdentifier:@&quot;test&quot;]; [self addChildViewController:controller]; controller.view.frame = CGRectMake(0, 44, 320, 320); [self.view addSubview:controller.view]; [controller didMoveToParentViewController:self]; // remove child viewController UIViewController *vc = [self.childViewControllers lastObject]; [vc.view removeFromSuperview]; [vc removeFromParentViewController];","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"设置NavigationBar导航栏中返回按钮(BackBarButtonItem)和BarButtonItem文字","date":"2016-10-20T17:13:00.000Z","path":"2016/10/20/设置NavigationBar导航栏中返回按钮(BackBarButtonItem)和BarButtonItem文字/","text":"1. 后退按钮BackBarButtonItem的title设置想要导航栏中后退按钮(带箭头，BackBarButtonItem)和BarButtonItem的文字，折腾了一会，试了几种方法都不奏效，最终找到了个解决办法。 如果APP通过navigationController从A视图跳转至B视图，导航的返回按钮的加载原理是这样的：1、如果B视图有一个自定义的左侧按钮（leftBarButtonItem），则会显示这个自定义按钮（没有后退箭头）；2、如果B没有自定义按钮，但是A视图的backBarButtonItem属性有自定义项，则显示这个自定义项；3、如果前2条都没有，则默认显示一个后退按钮，后退按钮的标题是A视图的标题（没有标题，则显示“back”）。（摘自博客： iOS 修改导航栏的返回按钮的内容 ） 所以我的实现方法是，在A视图跳转至B视图之前修改A视图的backBarButtonItem的title： - (IBAction)jumpAction:(id)sender { SecondViewController *secondVC = [[SecondViewController alloc] initWith]; [self setHidesBottomBarWhenPushed:YES]; UIBarButtonItem *backBtn = [[UIBarButtonItem alloc] initWithTitle:@&quot;返回&quot; style:UIBarButtonItemStylePlain target:nil action:nil]; self.navigationItem.backBarButtonItem = backBtn; [self.navigationController pushViewController:secondVC animated:YES]; } 效果如图： 2. 右侧按钮BarButtonItem的title设置这个实现比较简单，只需往B视图中的rightBarButtonItem添加一个BarButtonItem就可以，有两种样式（系统自带或自定义）。 2.1 系统自带：UIBarButtonItem *editBtn = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemEdit target:self action:@selector(editAction:)]; self.navigationItem.rightBarButtonItem = editBtn; 2.2 自定义：UIBarButtonItem *doneBtn = [[UIBarButtonItem alloc] initWithTitle:@&quot;保存&quot; style:UIBarButtonItemStyleDone target:self action:@selector(saveAction:)]; self.navigationItem.rightBarButtonItem = doneBtn;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"Objective-C常用宏定义","date":"2016-10-14T10:25:00.000Z","path":"2016/10/14/Objective-C常用宏定义 /","text":"看到 LvesLi’s Blogging 分享的一些Objective-C常用宏定义，非常好用，记录于此： //1. 打印日志 #ifdef DEBUG # define DLog(...) NSLog(__VA_ARGS__) #else # define DLog(…) #endif //2. 获取屏幕 宽度、高度 #define kScreenWidth ([UIScreen mainScreen].bounds.size.width) #define kScreenHeight ([UIScreen mainScreen].bounds.size.height) //3. 颜色 #define RGB(r, g, b, a) [UIColor colorWithRed:r/255.0f green:g/255.0f blue:b/255.0f alpha:a] #define HEXCOLOR(c) [UIColor colorWithRed:((c&gt;&gt;16)&amp;0xFF)/255.0f green:((c&gt;&gt;8)&amp;0xFF)/255.0f blue:(c&amp;0xFF)/255.0f alpha:1.0f] //背景色 #define BACKGROUND_COLOR [UIColor colorWithRed:242.0/255.0 green:236.0/255.0 blue:231.0/255.0 alpha:1.0] //清除背景色 #define CLEARCOLOR [UIColor clearColor] //4.加载图片宏： #define LOADIMAGE(file,type) [UIImage imageWithContentsOfFile:[[NSBundle mainBundle]pathForResource:file ofType:type]] //5. NavBar高度 #define NavigationBar_HEIGHT 44 //6. 获取系统版本 #define IOS_VERSION [[[UIDevice currentDevice] systemVersion] floatValue] #define CurrentSystemVersion [[UIDevice currentDevice] systemVersion] //7. 判断是真机还是模拟器 #if TARGET_OS_IPHONE //iPhone Device #endif #if TARGET_IPHONE_SIMULATOR //iPhone Simulator #endif //8. 设置View的tag属性 #define VIEWWITHTAG(_OBJECT, _TAG) [_OBJECT viewWithTag : _TAG] //9. GCD #define BACK(block) dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), block) #define MAIN(block) dispatch_async(dispatch_get_main_queue(),block) //10. NSUserDefaults 实例化 #define USER_DEFAULT [NSUserDefaults standardUserDefaults] 博文原地址： Objective-C 预处理器(The Preprocessor)","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"ViewController之间通信，传递参数","date":"2016-10-13T11:38:00.000Z","path":"2016/10/13/ViewController之间通信，传递参数 /","text":"从 FirstViewController 跳转到 SecondViewController ，当从 SecondViewController 返回时，如果想把数据回传给 FirstViewController ，可以用代理的方法， FirstViewController 中这样使用： FirstViewController.h @interface FirstViewController : UIViewController &lt;SecondViewControllerDelegate&gt; FirstViewController.m - (void)pushNextViewControl:(UIBarButtonItem *)button{ SecondViewController * showVC = [[SecondViewController alloc]init]; showVC.text = _textField.text; // 将代理对象设置成SecondViewController showVC.delegate = self; [self.navigationController pushViewController:showVC animated:YES]; [showVC release]; } // FirstViewController实现协议里面的方法 - (void)showViewGiveValue:(NSString *)text{ _inputLabel.text = text; } SecondViewController 需要这样设置代理： SecondViewController.h @protocol SecondViewControllerDelegate &lt;NSObject&gt; @optional - (void)showViewGiveValue:(NSString *)text; @end @interface SecondViewController : UIViewController @property (nonatomic,copy)NSString * text; // 定义一个代理 @property (nonatomic,assign)id&lt;SecondViewControllerDelegate&gt; delegate; @end SecondViewController.m - (void)popPerView:(UIBarButtonItem *)barButton{ // 在页面跳转前将参数传出去 if ([self.delegate respondsToSelector:@selector(showViewGiveValue:)]) { [self.delegate showViewGiveValue:_showTextField.text]; } [self.navigationController popViewControllerAnimated:YES]; }","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"给ViewController添加BarButton","date":"2016-10-13T11:06:00.000Z","path":"2016/10/13/给ViewController添加BarButton /","text":"用代码给UIViewController(self)添加BarButton时，下面的代码不起作用： self.navigationController.navigationItem.rightBarButtonItem = [[UIBarButtonItem alloc] initWithTitle:@&quot;xyz&quot; style:UIBarButtonItemStyleDone target:self action:@selector(xyz)]; 而这样就可以： self.navigationItem.rightBarButtonItem = [[UIBarButtonItem alloc] initWithTitle:@&quot;xyz&quot; style:UIBarButtonItemStyleDone target:self action:@selector(xyz)]; 关于 UINavigationItem ，苹果官网文档： This is a unique instance of UINavigationItem created to represent the viewcontroller when it is pushed onto a navigation controller. The first time theproperty is accessed, the UINavigationItem object is created. Therefore, youshould not access this property if you are not using a navigation controllerto display the view controller. To ensure the navigation item is configured,you can either override this property and add code to create the bar buttonitems when first accessed or create the items in your view controller’€™sinitialization code.Avoid tying the creation of bar button items in your navigation item to thecreation of your view controller’€™s view. The navigation item of a viewcontroller may be retrieved independently of the view controller’€™s view. Forexample, when pushing two view controllers onto a navigation stack, thetopmost view controller becomes visible, but the other view controller’€™snavigation item may be retrieved in order to present its back button.The default behavior is to create a navigation item that displays the viewcontroller’€™s title. 刘大帅 在他的博客 【iOS】导航栏那些事儿 详细解释了原因： 事实上，UINavigationController并没有navigationItem这样一个直接的属性，由于UINavigationController继承于UIViewController,而UIViewController是有navigationItem这个属性的，所以才会出现如图所示的情况。文／刘大帅（简书作者）原文链接： http://www.jianshu.com/p/f797793d683f# 著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。 还举了个很形象的栗子： 如果把导航控制器比作一个剧院，那导航栏就相当于舞台，舞台必然是属于剧院的，所以，导航栏是导航控制器的一个属性。视图控制器（UIViewController）就相当于一个个剧团，而导航项（navigation item）就相当于每个剧团的负责人，负责与剧院的人接洽沟通。显然，导航项应该是视图控制器的一个属性。虽然导航栏和导航项都在做与导航相关的事情，但是它们的从属是不同的。我想，这个类比应该能解决以上的疑惑吧。导航栏相当于负责剧院舞台的布景配置，导航项则相当于协调每个在舞台上表演的演员（bar buttonitem,title 等等），每个视图控制器的导航项可能都是不同的，可能一个右边有一个选择照片的bar buttonitem,而另一个视图控制器的右边有两个bar button item。文／刘大帅（简书作者）原文链接： http://www.jianshu.com/p/f797793d683f# 著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"NSDate获取指定格式的当地时间","date":"2016-10-10T09:14:00.000Z","path":"2016/10/10/NSDate获取指定格式的当地时间 /","text":"方法 [NSDate date] 默认获得的是0时区的时间，想要得到当前的北京时间需要手动指定时区： NSDate *currentDate=[NSDate date]; NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; [formatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;]; //指定输出格式 [formatter setTimeZone:[NSTimeZone timeZoneWithName:@&quot;Asia/Beijing&quot;]]; //设置当地时区 NSString *currentDateString = [formatter stringFromDate:currentDate];","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"让SVProgressHUD提示框自动消失","date":"2016-09-13T00:05:00.000Z","path":"2016/09/13/让SVProgressHUD提示框自动消失 /","text":"SVProgressHUD 是一个第三方提示器框架。现在想实现提示框2秒后自动消失的效果，便有了以下尝试： // 可以自动消失的三种提示框 [SVProgressHUD showInfoWithStatus:@&quot;数据加载完毕！&quot;]; [SVProgressHUD showSuccessWithStatus:@&quot;成功加载到4条新数据！&quot;]; [SVProgressHUD showErrorWithStatus:@&quot;网络错误，请稍等！&quot;]; // 设置四周阴影 [SVProgressHUD showWithMaskType:SVProgressHUDMaskTypeBlack]; 使用上面的方法，它要过四五秒才消失。要实现2秒后自动消失的效果，有两种方法：第一种（SVProgressHUD版本必须2.0.4以后）： [SVProgressHUD showSuccessWithStatus:@&quot;Done!&quot;]; [SVProgressHUD dismissWithDelay:2.0f]; 第二种： // 延迟2秒后消失 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ [SVProgressHUD dismiss]; }); 在第二种方法中用到的 dispatch_after 是一种 GCD ，关于GCD，详见 唐巧博客 ： Grand Central Dispatch (GCD) 是 Apple 开发的一个多核编程的解决方法。该方法在 Mac OS X 10.6 雪豹中首次推出，并随后被引入到了 iOS4.0 中。GCD 是一个替代诸如 NSThread, NSOperationQueue, NSInvocationOperation 等技术的很高效和强大的技术。 GCD 和 block 的配合使用，可以方便地进行多线程编程。 而 dispatch_after ： dispatch_after 功能：延迟一段时间把一项任务提交到队列中执行，返回之后就不能取消 常用来在在主队列上延迟执行一项任务 函数原型:func dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block); 参数：when 过了多久执行的时间间隔 queue 提交到的队列 block 执行的任务","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"NSTableView的背景色设置","date":"2016-09-08T13:24:00.000Z","path":"2016/09/08/NSTableView的背景色设置 /","text":"在设置 NSTableView 背景色时，发现它其实包含三层 view ： NSScrollView 、 NSClipView 、 NSTableView 。与之对应的视图：所以想要设置 NSTableView 为透明的话，除了[tableView setBackgroundColor:[NSColor clearColor]];以外，还需要设置[tableView enclosingScrollView] setDrawsBackground:NO];让围绕它的 ScrollView 不要填涂背景色。这样才真正做到 TableView 的透明","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"自动布局(AutoLayout)的三种方式","date":"2016-09-07T23:37:00.000Z","path":"2016/09/07/自动布局(AutoLayout)的三种方式 /","text":"在斯坦福公开课中，白胡子老爷爷教了三种自动布局的方法：1. 控件布局都处在建议的蓝虚线上时，使用 Reset to Suggested Constraints 。2. 使用对齐约束 Alignment Constraints 或者距离约束： 3. 通过 Ctrl Drag 在两个视图/控件之间创建约束，按住 Shift 同时设定多个约束。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"JavaScript与Objective-C之间的通信","date":"2016-08-31T20:14:00.000Z","path":"2016/08/31/JavaScript与Objective-C之间的通信 /","text":"转自 老谭的博客 ： JavaScript与Objective-C之间的通信 1、JS中变量在OC中的类型通过OC-JS Bridge，变量的类型会自动进行转换，基本类型都会自动转换，如JS中的number、boolean都会转换成OC中的NSNumber类型，而String类型会自动转换成NSString类型，JS中的对象会转换成WebScriptObject对象，而相关的属性信息可以通过Key-Value的方法读取和写入，本文后面可看到相关的代码。2、实现在OC中调用JS方法在OC中调用JS方法是非常方便的，WebView有一个windowScriptObject属性，可以直接获得脚本对象，然后便可以调用callWebScriptMethod:withArguments将消息转发给JS中对象的方法和参数，对于简单的方法调用你也可以直接通过WebView的方法stringByEvaluatingJavaScriptFromString去执行一段JS代码，并返回字符串。示例代码： //在OC中的调用 - (void)ocAction:(id)sender { NSArray *args = @[@&quot;Hello,JS!&quot;]; id result = [[webView windowScriptObject] callWebScriptMethod:@&quot;JSFunction&quot; withArguments:args]; NSLog(@&quot;%@&quot;,result); } //在JS中对应的方法 function JSFunction(parameter) { //显示OC返回的值 alert(parameter); //返回成功的消息 return &apos;Web程序已经收到消息！&apos;; } 3、实现JS调用OC的方法通过设置webView的frameLoadDelegate，在– webView:didClearWindowObject:forFrame:回调方法中，指定一个本地对象（该对象实现WebScripting协议），然后JS中就可以直接调用该对象的相关方法。OC中的代码如下： //该方法用于JS中调用 - (WebScriptObject *)status:(WebScriptObject *)jsObject { //将JS发过来的信息显示出来 NSString *message = [jsObject valueForKey:@&quot;message&quot;]; NSLog(@&quot;%@&quot;,message); //返回成功的信息(WebScriptObject对象不能自己创建，所以此处复用了传入的参数) [jsObject setValue:@&quot;本地端已经收到消息啦！&quot; forKey:@&quot;message&quot;]; return jsObject; } #pragma mark - #pragma mark WebFrameLoadDelegate //通过此回调，将self传递给JS环境 - (void)webView:(WebView *)sender didClearWindowObject:(WebScriptObject *)windowObject forFrame:(WebFrame *)frame { [windowObject setValue:self forKey:@&quot;native&quot;]; } #pragma mark - #pragma mark WebScriptingProtocol /* 返回是否阻止响应该方法, 返回NO即能响应该方法 */ + (BOOL)isSelectorExcludedFromWebScript:(SEL)selector { if (selector == @selector(status:)) { return NO; } return YES; } /* 返回本地方法在JS中的名称(不实现此方法，则JS中方法名与OC中相同) */ + (NSString *)webScriptNameForSelector:(SEL)sel { if (sel == @selector(status:)) { return @&quot;ocMethod&quot;; } return nil; } JS中代码如下： function CallNative() { if (native) { //将消息组装成对象发给OC var parameter = {&apos;message&apos;:&apos;Hello,Objective-C!&apos;}; var result = native.ocMethod(parameter); //显示OC返回的结果 alert(result[&apos;message&apos;]); } }","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"根据页面滚动动态修改UINavigationBar的背景色","date":"2016-08-28T16:10:00.000Z","path":"2016/08/28/根据页面滚动动态修改UINavigationBar的背景色 /","text":"最近要实现UINavigationBar背景动态改变的功能，找到了 Glow 技术团队博客 的博文： 动态修改UINavigationBar的背景色 ，很好的满足了我的功能需求，是个极好的轮子。fork了他们的项目源码： LTNavigationBar","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"根据字符串长度动态计算UILabelView的高度","date":"2016-08-28T15:39:00.000Z","path":"2016/08/28/根据字符串长度动态计算UILabelView的高度 /","text":"在调用 UILabelView 时， Label 的高度最好根据字符串长度动态设置，为了实现这一点，我们可以用 NSAttributedString 的 \\- (CGRect)boundingRectWithSize: options: context:方法，实现方法： if (labelText){ NSMutableAttributedString *attrStr = [[NSMutableAttributedString alloc] initWithString:labelText]; NSRange allRange = [labelText rangeOfString:labelText]; [attrStr addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:13.0] range:allRange]; //根据字符串长度计算所需的矩形框大小，其中需要指定“MAX_WIDTH”，根据这一宽度约束和字符串长度动态计算得到矩形框高度 CGRect rect = [attrStr boundingRectWithSize:CGSizeMake(MAX_WIDTH, MAX_HEIGHT) options:NSStringDrawingUsesLineFragmentOrigin | NSStringDrawingTruncatesLastVisibleLine context:nil]; //adjust the label the the new height. CGRect newFrame = myLabel.frame; newFrame.size.height = ceil(rect.size.height); myLabel.frame = newFrame; }","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"UIView的重绘机制——drawRect","date":"2016-08-18T10:08:00.000Z","path":"2016/08/18/UIView的重绘机制——drawRect /","text":"斯坦福公开课 第七课.Views and Gestures ，提到了UIView的重绘函数 drawRect ，其中用到了 UIBezierPath 类来创建基于矢量的路径，基本用法：","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"NavigationBar导航栏透明","date":"2016-08-12T18:49:00.000Z","path":"2016/08/12/NavigationBar导航栏透明 /","text":"想要得到导航栏透明的视图控制器(ViewController)，效果如下图： 而默认情况下，导航栏是这样的： 想要让导航栏透明，可以这样实现：在视图控制器(ViewController) -(void)viewWillAppear: 中进行以下设置： -(void)viewWillAppear:(BOOL)animated { [super viewWillAppear:animated]; [self.navigationController.navigationBar setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault]; //设置一张空白图片 self.navigationController.navigationBar.shadowImage = [UIImage new]; //导航栏的下底边也是一张图片，也许要设置成空白图片 } 这样就把导航栏透明设置好了，不过导航控制器(navigationController)是多个视图控制器共用的，这样设置之后，其他视图控制器的导航栏也会变透明，所以要在当前视图控制器退出的时候(viewWillDisappear)将导航栏复原： -(void)viewWillDisappear:(BOOL)animated { [super viewWillDisappear:animated]; [self.navigationController.navigationBar setBackgroundImage:nil forBarMetrics:UIBarMetricsDefault]; [self.navigationController.navigationBar setShadowImage:nil]; } 不过设置完透明，导航栏下的 tableView 并没有置顶，而是留了块白条： 这里还需要设置当前视图控制器的另外一属性 automaticallyAdjustsScrollViewInsets - (void)viewDidLoad { [super viewDidLoad]; self.automaticallyAdjustsScrollViewInsets = NO; } 这样就能达到我们预期的效果了。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"深度解析H.264编码原理","date":"2016-08-10T19:54:08.000Z","path":"2016/08/10/phrase-h264-nalu/","text":"转自ffmpeg开发之旅(2)：深度解析H.264编码原理 前 言在学习H.264编码之前，我们先了解一下在视频直播的过程中，如果Camera采集的YUV图像不做任何处理进行传输，那么每秒钟需要传输的数据量是多少？Camera采集的YUV图像通常为YUV420，根据YUV420的采样结构，YUV图像中的一个像素中Y、U、V分量所占比例为1：1/4：1/4，而一个Y分量占1个字节，也就是说对于YUV图像，它的一个像素的大小为(1+1/4+1/4)Y=3/2个字节。如果直播时的帧率设置为30fps，当分辨率为1280x720，那么每秒需要传输的数据量为1280720(像素)30(帧)3/2(字节)=39.5MB；当分辨率为1920x720，那么每秒需要传输的数据量接近60MB，而在现实网络中，这么高的上行宽带一般是很难达到的，因此，我们就必须在传输之前对采集的视频数据进行压缩编码。 一. H.264简介H.264是MPEG-4的第十部分，是由VCEG和MPEG联合提出的高度压缩数字视频编码器标准，目前在多媒体开发应用中非常广泛。H.264具有低码率、高压缩、高质量的图像、容错能力强、网络适应性强等特点，它最大的优势拥有很高的数据压缩比率，在同等图像质量的条件下，H.264的压缩比是MPEG-2的两倍以上。 1. H.264编码原理在H.264协议里定义了三种帧，完整编码的帧叫I帧(关键帧)，参考之前的I帧生成的只包含差异部分编码的帧叫P帧，还有一种参考前后的帧编码的帧叫B帧。H.264编码采用的核心算法是帧内压缩和帧间压缩。其中，帧内压缩是生成I帧的算法，它的原理是当压缩一帧图像时，仅考虑本帧的数据而不用考虑相邻帧之间的冗余信息，由于帧内压缩是编码一个完整的图像，所以可以独立的解码显示；帧间压缩是生成P、B帧的算法，它的原理是通过对比相邻两帧之间的数据进行压缩，进一步提高压缩量，减少压缩比。通俗的来说，H.264编码的就是对于一段变化不大图像画面，我们可以先编码出一个完整的图像帧A，随后的B帧就不编码全部图像，只写入与A帧的差别，这样B帧的大小就只有完整帧的1/10或更小。B帧之后的C帧如果变化不大，我们可以继续以参考B的方式编码C帧，这样循环下去。H.264编码框架分两层：VCL(Video Coding Layer)：负责高效的视频内容表示；NAL(Network Abstraction Layer)：负责以网络所要求的恰当的方式对数据进行打包和传送； #####2. IDR(I帧)、SPS、PPS、SES、P/B帧 IDR(Instantaneous Decoding Refresh)：即时解码刷新。一个序列的第一个图像叫做IDR 图像（立即刷新图像），IDR 图像都是I 帧图像(关键帧)。H.264引入 IDR 图像是为了解码的重同步，当解码器解码到IDR 图像时，立即将参考帧队列清空，将已解码的数据全部输出或抛弃，重新查找参数集，开始一个新的序列。这样，如果前一个序列出现重大错误，在这里可以获得重新同步的机会。IDR图像之后的图像永远不会使用IDR之前的图像的数据来解码。 SPS(Sequence Parameter Sets)：序列参数集，作用于一系列连续的编码图像。 PPS(Picture Parameter Set)：图像参数集，作用于编码视频序列中一个或多个独立的图像。 SEI(Supplemental Enhancement Information)：附加增强信息，包含了视频画面定时等信息，一般放在主编码图像数据之前，在某些应用中，它可以被省略掉。 P帧：前向预测编码帧。P帧表示的是这一帧跟之前的一个关键帧（或P帧）的差别，它P帧是I帧后面相隔1~2帧的编码帧，其没有完整画面数据，只有与前一帧的、画面差别的数据。 B帧：双向预测内插编码帧。B帧记录的是本帧与前后帧的差别，它是由前面的I或P帧和后面的P帧来进行预测的。#####3. H.264与X.264区别H.264是需要付费的编码格式，而x264是符合H.264标准的一个开源项目，是免费的，也就是H264的一个简化版，不支持某些高级特性。但x264非常优秀，并不比H264的商业编码器差。H264采用的核心算法是帧内压缩和帧间压缩，帧内压缩是生成I帧的算法，帧间压缩是生成B帧和P帧的算法。####二. H.264数据组织形式通常，数据的组织形式从大到小排序是：序列(sequence)、图像(frame/field-picture)、片组(slicegroup)、片(slice)、宏块(macroblock)、块(block)、子块(sub-block)、像素(pixel)。在H.264码流中图像是以序列为单位进行组织的，一个序列是由多帧图像被编码后的数据流，以I帧开始，到下一个I帧结束；一帧图像可以分成一个或多个片(slice)，片由宏块组成，宏块是编码处理的基本单位，当片编码之后会被打包进一个NALU，也就是一帧图像对应于一个NALU。NALU是H.264编码数据存储或传输的基本单位，它除了容纳片还可以容纳其他数据，如SPS、PPS、SEI等。根据H.264编码原理可知，一个序列是一段内容差异不太大的图像编码生成的一串数据流。当运动变化比较少时，一个序列可以很长，这是由于运动变化少就代表图像画面的内容变动就很小，所有就可以编一个I帧，然后后面一直P帧、B帧；当运动变化较大，可能这个序列就比较短，因为图像画面的内容变动大，所以P帧、B帧就相对减少。总之，一个序列总是以I帧为开始，到下一个I帧结束，序列包含的图像帧的数量与画面变化情况有关。####三. H.264中的NAL技术从H.264的介绍可知，NAL是H.264/AVC编码框架中的网络抽象层，即NetworkAbstract Layer，它主要负责格式化数据并提供头信息，以保证数据适合各种信道和存储介质上的有效传输。由于实际中的信息传输系统可靠性、封装方式、服务质量等特征的多样化，NAL提供了一个视频编码器和传输系统的友好接口，使得编码后的视频数据能够有效地在各种不同的网络环境中传输。在NAL层中，NALU(Network Abstract Layer Unit，网络抽象层单元)是H.264编码存储或传输的基本单位，在H.264码流中每一帧数据就是一个NALU(注：SPS、PPS、SEI不属于帧)。每个NALU都包含一个头结构，这个头结构占1个字节(8位)，它标明了该NAL单元的是否可丢弃、重要性指示和NALU类型，结构如下：其中： 禁止位：当网络发现NALU存在错误时，该位将被设置为1以方便接收方丢弃该NALU； 重要性指示：用于标志该NALU用于重建时的重要性，其值越大表示越重要； NALU类型：用于判断该NALU是否为PPS、SPS、I(关键)/P/B帧等，一般H.264码流最开始的两个NALU是SPS和PPS，第三个NALU是IDR(I帧)。NALU类型是判断帧类型重要工具，至于如何去利用它来实现SPS、PPS和I/P/B帧等信息的检测，我们接下来会举例详细介绍，以下是相关值与NALU类型的映射关系图：从上图可知，当NALU类型=5时，说明该NALU是关键帧(I帧)；当NALU类型=6时，说明该NALU是附加增强信息；当NALU类型=7时，说明该NALU是序列参数集(SPS)；当NALU类型=8时，说明该NALU是图像参数集(PPS)，依次类推。####四. H.264中SPS、PPS、I/P/B帧检测与解析 H.264码流分层结构在分析SPS、PPS、I/P/B帧之前，我们先了解下H.264码流分层的结构。从外往里看，H.264码流实际是由多个NALU组成的码流序列集合(如第一层所示)，而一个序列是以I帧开始，以下一个I帧结束。NALU是H.264编码存储或传输的基本单元，NALU由NALU 头部和NALU主体组成(如第二层所示)，其中，NALU头部占1个字节，H.264中的SPS、PPS、I/P/B帧的检测正是通过NALU头部中的NALU类型来实现的。H.264码流分层结构如下图所示： H.264文件解析一般来说，编码器编出的首帧数据为SPS与PPS，接着为I帧(关键帧)，再后面就是P帧、B帧…。而对于H.264码流而言，每帧图像的界定符为0x00000001、0x000001，也称起始码，它们分别占4个字节或3个字节,而起始码的后的一个字节便是NALU头，通过这个字节我们就可以很简单的找到所需的SPS、PPS、I/P/B帧。这里，我们通过分析一个H.264文件来进行讲解，使用H.264 Video ES Viewer工具打开一个test.264文件，至于h264文件的生成，我将再下一篇博文进行详细介绍，H264码流结构如下图：从上图可知，每一行表示一帧图像(除SPS、PPS除外)，每一行包括四列，其中第一列为该帧图像存储的逻辑地址；第二列为该帧图像数据所占字节长度，由于H264的编码原理可以知道，H264码流中的每一帧图像并不是实际上的一帧图像，而是多帧图像的集合；第三列表示图像帧的起始码，均为0x00000001；第四列表示的是NAL类型，由图可知，H264编码器编出的首帧数据为SPS与PPS，接着为I帧(关键帧)，再后面就是P帧或B帧(非I帧)。 SPS、PPS、I/P/B帧检测有了前面的理论和分析基础，再来判断H.264码流中的(3) SPS、PPS、I/P/B帧，那就显得非常容易了。我们知道，H.264码流中的一帧数据总是以0x00000001或0x000001开始的，起始码的下一位就是NALU头，比如第一帧数据NALU头为0x67，我们截取码流中的前几帧数据进行分析：12345第一帧：0000 00 01 67 42 80 1F DA 02 D0 28 68 ….（占17个字节）第二帧：0000 00 01 68 CE 06 E2 (占8个字节)第三帧：0000 00 01 65 B8 40 F7 8F FC EB 04 …. (占31872个字节)第四帧：0000 00 01 41 E2 01 10 EA 4E 9F … (占3408字节)第五帧：0000 00 01 41 E4 01 10 EC 7B DF 13 … (占2096个字节) 由于NALU类型由NALU头的后五位决定的，即字节下标的3-7位，我们只需要得到这五位的十进制值，再与NAL类型对照表进行比较就可以知道该帧图像是否为SPS、PPS或I帧(关键帧)等。在编码过程中，我们可以通过将每帧数据起始码的下一个字节与0x1F相与取得NAL头的后五位即可得到该帧的类型，比如：12340x67&amp; 0x1F = (0110 0111) &amp; (0001 1111) =(0000 0111)=7(十进制)–&gt; SPS0x68&amp; 0x1F = (0110 1000) &amp; (0001 1111) =(0010 1000)=8(十进制)–&gt; PPS0x65&amp; 0x1F = (0110 0101) &amp; (0001 1111) =(0000 0101)=5(十进制)–&gt; 关键帧(I帧)0x41 &amp; 0x1F = (01000001) &amp; (0001 1111) =(0000 0001)=1(十进制) –&gt; 非关键帧(I帧) 参考：(1). H264的I帧/P帧/B帧：http://www.embeddedlinux.org.cn/html/xinshourumen/201407/15-2895.html(2). H264码流分析：http://www.lxway.com/214559661.htm","tags":[{"name":"编解码","slug":"编解码","permalink":"http://ichenwin.github.io/tags/编解码/"},{"name":"视频","slug":"视频","permalink":"http://ichenwin.github.io/tags/视频/"}]},{"title":"视图控制器生命周期(ViewController Lifecycle)","date":"2016-08-10T09:17:00.000Z","path":"2016/08/10/视图控制器生命周期(ViewController Lifecycle) /","text":"斯坦福公开课第五课 5\\. View Controller Lifecycle.mp4 总结了 View Controller的生命周期。如图：","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"改变PageControl指示点的颜色","date":"2016-08-08T15:51:00.000Z","path":"2016/08/08/改变PageControl指示点的颜色 /","text":"PageControl指示点的颜色默认是白色，此时若背景也是白色，就完全看不到PageControl控件。那么需要更改指示点的颜色： _pageCtrl.numberOfPages = ceil([dataArr count] / 3.0); //设置指示点个数 _pageCtrl.currentPage = 0; //设置当前页指示点 _pageCtrl.pageIndicatorTintColor = [UIColor lightGrayColor]; //设置未激活的指示点颜色 _pageCtrl.currentPageIndicatorTintColor = [UIColor blackColor]; //设置当前页指示点颜色 至于PageControl的其他用法，下面是它的点击事件： [page addTarget:self action:@selector(mypageclick:) forControlEvents:UIControlEventValueChanged]; #prag mark - 点击事件执行方法 - (void)mypageclick:(UIPageControl*)page{ //你的代码 }","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"H.264编码原理以及I/B/P帧","date":"2016-08-06T11:34:08.000Z","path":"2016/08/06/h264-principle/","text":"前言H264是新一代的编码标准，以高压缩高质量和支持多种网络的流媒体传输著称，在编码方面，我理解的他的理论依据是：参照一段时间内图像的统计结果表明，在相邻几幅图像画面中，一般有差别的像素只有10%以内的点,亮度差值变化不超过2%，而色度差值的变化只有1%以内。所以对于一段变化不大图像画面，我们可以先编码出一个完整的图像帧A，随后的B帧就不编码全部图像，只写入与A帧的差别，这样B帧的大小就只有完整帧的1/10或更小！B帧之后的C帧如果变化不大，我们可以继续以参考B的方式编码C帧，这样循环下去。这段图像我们称为一个序列（序列就是有相同特点的一段数据），当某个图像与之前的图像变化很大，无法参考前面的帧来生成，那我们就结束上一个序列，开始下一段序列，也就是对这个图像生成一个完整帧A1，随后的图像就参考A1生成，只写入与A1的差别内容。在H264协议里定义了三种帧，完整编码的帧叫I帧，参考之前的I帧生成的只包含差异部分编码的帧叫P帧，还有一种参考前后的帧编码的帧叫B帧。H264采用的核心算法是帧内压缩和帧间压缩，帧内压缩是生成I帧的算法，帧间压缩是生成B帧和P帧的算法。 序列的说明在H264中图像以序列为单位进行组织，一个序列是一段图像编码后的数据流，以I帧开始，到下一个I帧结束。一个序列的第一个图像叫做 IDR 图像（立即刷新图像），IDR 图像都是 I 帧图像。H.264 引入 IDR 图像是为了解码的重同步，当解码器解码到 IDR 图像时，立即将参考帧队列清空，将已解码的数据全部输出或抛弃，重新查找参数集，开始一个新的序列。这样，如果前一个序列出现重大错误，在这里可以获得重新同步的机会。IDR图像之后的图像永远不会使用IDR之前的图像的数据来解码。一个序列就是一段内容差异不太大的图像编码后生成的一串数据流。当运动变化比较少时，一个序列可以很长，因为运动变化少就代表图像画面的内容变动很小，所以就可以编一个I帧，然后一直P帧、B帧了。当运动变化多时，可能一个序列就比较短了，比如就包含一个I帧和3、4个P帧。 三种帧的说明I帧:帧内编码帧 ，I帧表示关键帧，你可以理解为这一帧画面的完整保留；解码时只需要本帧数据就可以完成（因为包含完整画面）I帧特点: 它是一个全帧压缩编码帧。它将全帧图像信息进行JPEG压缩编码及传输; 解码时仅用I帧的数据就可重构完整图像; I帧描述了图像背景和运动主体的详情; I帧不需要参考其他画面而生成; I帧是P帧和B帧的参考帧(其质量直接影响到同组中以后各帧的质量); I帧是帧组GOP的基础帧(第一帧),在一组中只有一个I帧; I帧不需要考虑运动矢量; I帧所占数据的信息量比较大。 P帧:前向预测编码帧。P帧表示的是这一帧跟之前的一个关键帧（或P帧）的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。（也就是差别帧，P帧没有完整画面数据，只有与前一帧的画面差别的数据）P帧的预测与重构:P帧是以I帧为参考帧,在I帧中找出P帧“某点”的预测值和运动矢量,取预测差值和运动矢量一起传送。在接收端根据运动矢量从I帧中找出P帧“某点”的预测值并与差值相加以得到P帧“某点”样值,从而可得到完整的P帧。P帧特点: P帧是I帧后面相隔1~2帧的编码帧; P帧采用运动补偿的方法传送它与前面的I或P帧的差值及运动矢量(预测误差); 解码时必须将I帧中的预测值与预测误差求和后才能重构完整的P帧图像; P帧属于前向预测的帧间编码。它只参考前面最靠近它的I帧或P帧; P帧可以是其后面P帧的参考帧,也可以是其前后的B帧的参考帧; 由于P帧是参考帧,它可能造成解码错误的扩散; 由于是差值传送,P帧的压缩比较高。 B帧:双向预测内插编码帧。B帧是双向差别帧，也就是B帧记录的是本帧与前后帧的差别（具体比较复杂，有4种情况，但我这样说简单些），换言之，要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是解码时CPU会比较累。B帧的预测与重构B帧以前面的I或P帧和后面的P帧为参考帧,“找出”B帧“某点”的预测值和两个运动矢量,并取预测差值和运动矢量传送。接收端根据运动矢量在两个参考帧中“找出(算出)”预测值并与差值求和,得到B帧“某点”样值,从而可得到完整的B帧。B帧特点1.B帧是由前面的I或P帧和后面的P帧来进行预测的;2.B帧传送的是它与前面的I或P帧和后面的P帧之间的预测误差及运动矢量;3.B帧是双向预测编码帧;4.B帧压缩比最高,因为它只反映丙参考帧间运动主体的变化情况,预测比较准确;5.B帧不是参考帧,不会造成解码错误的扩散。 注:I、B、P各帧是根据压缩算法的需要，是人为定义的,它们都是实实在在的物理帧。一般来说，I帧的压缩率是7（跟JPG差不多），P帧是20，B帧可以达到50。可见使用B帧能节省大量空间，节省出来的空间可以用来保存多一些I帧，这样在相同码率下，可以提供更好的画质。 压缩算法的说明h264的压缩方法: 分组:把几帧图像分为一组(GOP，也就是一个序列),为防止运动变化,帧数不宜取多。 定义帧:将每组内各帧图像定义为三种类型,即I帧、B帧和P帧; 预测帧:以I帧做为基础帧,以I帧预测P帧,再由I帧和P帧预测B帧; 数据传输:最后将I帧数据与预测的差值信息进行存储和传输。 帧内（Intraframe）压缩也称为空间压缩（Spatial compression）。当压缩一帧图像时，仅考虑本帧的数据而不考虑相邻帧之间的冗余信息，这实际上与静态图像压缩类似。帧内一般采用有损压缩算法，由于帧内压缩是编码一个完整的图像，所以可以独立的解码、显示。帧内压缩一般达不到很高的压缩，跟编码jpeg差不多。帧间（Interframe）压缩的原理是：相邻几帧的数据有很大的相关性，或者说前后两帧信息变化很小的特点。也即连续的视频其相邻帧之间具有冗余信息,根据这一特性，压缩相邻帧之间的冗余量就可以进一步提高压缩量，减小压缩比。帧间压缩也称为时间压缩（Temporal compression），它通过比较时间轴上不同帧之间的数据进行压缩。帧间压缩一般是无损的。帧差值（Frame differencing）算法是一种典型的时间压缩法，它通过比较本帧与相邻帧之间的差异，仅记录本帧与其相邻帧的差值，这样可以大大减少数据量。顺便说下有损（Lossy ）压缩和无损（Lossy less）压缩。无损压缩也即压缩前和解压缩后的数据完全一致。多数的无损压缩都采用RLE行程编码算法。有损压缩意味着解压缩后的数据与压缩前的数据不一致。在压缩的过程中要丢失一些人眼和人耳所不敏感的图像或音频信息,而且丢失的信息不可恢复。几乎所有高压缩的算法都采用有损压缩,这样才能达到低数据率的目标。丢失的数据率与压缩比有关,压缩比越小，丢失的数据越多,解压缩后的效果一般越差。此外,某些有损压缩算法采用多次重复压缩的方式,这样还会引起额外的数据丢失。 转自：H264–1–编码原理以及I帧B帧P帧","tags":[{"name":"编解码","slug":"编解码","permalink":"http://ichenwin.github.io/tags/编解码/"},{"name":"视频","slug":"视频","permalink":"http://ichenwin.github.io/tags/视频/"}]},{"title":"为UIView添加点击事件","date":"2016-08-05T17:25:00.000Z","path":"2016/08/05/为UIView添加点击事件 /","text":"最近经常碰到要将UIImageView和UILabel看成整体的情况，我于是就将他俩用UIView包起来，那么怎么给一个UIView添加点击事件，可以这么实现： //将UIView设为可交互的： view.userInteractionEnabled = YES; //添加tap手势 UITapGestureRecognizer* singleTap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(handleSingleTap:)]; //给触发事件传参 [view setTag:i]; //默认为单击触发，也可通过以下方法设置双击，三击… [handleSingleTap setNumberOfTapsRequired:1]; //设置手指个数： [handleSingleTap setNumberOfTouchesRequired:1]; //将手势添加至UIView中 [view addGestureRecognizer:singleTap]; 执行触发的方法： -(void)handleSingleTap:(UITapGestureRecognizer *)sender{ //获得参数 NSInteger index = sender.view.tag; //在这里写触发事件 }","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"设置SearchBar文字字体","date":"2016-08-03T16:25:00.000Z","path":"2016/08/03/设置SearchBar文字字体 /","text":"SearchBar 内虽然含有一个 UITextField ，但是并没有可以直接访问的属性，要想更改 TextField的字体，可以用以下间接的方法实现： [[UITextField appearanceWhenContainedIn:[UISearchBar class], nil] setDefaultTextAttributes:@{ NSFontAttributeName: [UIFont fontWithName:@&quot;Helvetica&quot; size:20], }]; StackOverFlow上的讨论","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"解除嵌套UIScrollView之间的联动","date":"2016-08-02T20:29:00.000Z","path":"2016/08/02/解除嵌套UIScrollView之间的联动 /","text":"一般情况下，在两个嵌套UIScrollView中，innerView滑到顶的时候，会联动outterView开始滚动，为了解除滚动，可以在innerView的 .m 文件添加以下代码：(代码来自 iwevon 在简书的博客 ScrollView包含TableView解除联动 ) /************************************************** question: 当tableView被 父控件(scrollView或其子类) 所包含时,当tableView滑动到顶部时, 再次下拉滑动tableView时,scrollView会其联动 -------------------------------------------------- answer: 通过响应者链,获取父控件(scrollView或其子类)对象,修改其&apos;scrollEnabled&apos;属性,解除联动 */ - (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event { UIView *view = [super hitTest:point withEvent:event]; //使用响应者链解决 UIResponder *responder = [self nextResponder]; UIScrollView *scrollView = nil; //responder==nil:说明tableView未被scrollView包含 scrollView!=nil:说明按照条件获取到父控件(scrollView或其子类)对象 while (responder &amp;&amp; scrollView == nil) { //如果是父控件(scrollView或其子类)就返回,说明tableview被scrollView包含关系 if ([responder isKindOfClass:[UIScrollView class]]) { scrollView = (UIScrollView *)responder; } else { //根据响应者链去获取下一个响应者对象 responder = [responder nextResponder]; } } //scrollView为空时不会发送消息 if (view) { //当view!=nil时,(view类型为UITableViewCellContentView)需要关闭响应者链中scrollView滑动手势 scrollView.scrollEnabled = NO; } else { //当view==nil时,说明手势操作不是tableView发出的 scrollView.scrollEnabled = YES; } return view; }","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"通过UIImageView的tag为点击事件UITapGestureRecognizer传参","date":"2016-07-29T16:23:00.000Z","path":"2016/07/29/通过UIImageView的tag为点击事件UITapGestureRecognizer传参/","text":"为了点击图片时，知道哪张图片被点击，需要向 UITapGestureRecognizer 传递一个参数，此处使用了 UIImageView的 tag 属性，直接将图片索引写入 imageview 的 tag ，然后通过 sender.view.tag去获取图片索引。 UIImageView *imageview = [[UIImageView alloc] initWithImage: [UIImage imageNamed:@&quot;tab-me-plese.png&quot;]]; UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(processTap:)]; [imageview setTag:i]; //set tag value [imageview addGestureRecognizer:tap]; [imageview setUserInteractionEnabled:YES]; - (void)processTap:(UIGestureRecognizer *)sender { NSLog(@&quot;点击了第%ld张图片&quot;, sender.view.tag); }","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"NSAttributedString——为Label设置富文本","date":"2016-07-27T19:29:00.000Z","path":"2016/07/27/NSAttributedString——为Label设置富文本 /","text":"为了在同一个Label中显示两种颜色的字符，如下图（浅灰和黑色）：这里用到了 NSMutableAttributedString ，它可以创建自定义属性的富文本。和它同类的还有 NSAttributedString 。要实现上面一个Label中含两种颜色字符的效果，将汉字颜色设置成浅灰色，用了下面简单的代码实现： _followerLabel.text = @&quot;关注 11&quot;; NSRange followerRange = [_followerLabel.text rangeOfString:@”关注”]; NSMutableAttributedString *followerText = [[NSMutableAttributedString alloc] initWithString:_followerLabel.text]; [followerText beginEditing]; [followerText setAttributes:@{NSForegroundColorAttributeName: [UIColor colorWithRed:36.0f/255.0f green:36.0f/255.0f blue:36.0f/255.0f alpha:0.6]} range:followerRange]; [followerText endEditing]; _followerLabel.attributedText = followerText;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://ichenwin.github.io/tags/iOS/"}]},{"title":"VMware拷贝得的CentOS网络配置","date":"2016-05-18T19:36:08.000Z","path":"2016/05/18/VMware拷贝得的CentOS网络配置/","text":"VMware拷贝得的CentOS网络报错：Device eth0 does not seem to be present 一、问题描述从VMware克隆至别处的CentOS，ifconfig里面没有eth0。然后重启网卡会报以下错误：1234service network restartShutting down loopback insterface: [ OK ]Bringing up loopback insterface: [ OK ]Bringing up interface eth0: Device eth0 does not seem to be present,delaying initialization. [FAILED] 二、解决办法首先，打开/etc/udev/rules.d/70-persistent-net.rules内容如下面例子所示：12345678910# vi /etc/udev/rules.d/70-persistent-net.rules# This file was automatically generated by the /lib/udev/write_net_rules# program, run by the persistent-net-generator.rules rules file.## You can modify it, as long as you keep each rule on a single# line, and change only the value of the NAME= key.# PCI device 0x1022:0x2000 (pcnet32)SUBSYSTEM==\"net\", ACTION==\"add\", DRIVERS==\"?*\", ATTR&#123;address&#125;==\"00:0c:29:8f:89:97\", ATTR&#123;type&#125;==\"1\", KERNEL==\"eth*\", NAME=\"eth0\"# PCI device 0x1022:0x2000 (pcnet32)SUBSYSTEM==\"net\", ACTION==\"add\", DRIVERS==\"?*\", ATTR&#123;address&#125;==\"00:0c:29:50:bd:17\", ATTR&#123;type&#125;==\"1\", KERNEL==\"eth*\", NAME=\"eth1\" 记录下，eth1网卡的mac地址00:0c:29:50:bd:17接下来，打开/etc/sysconfig/network-scripts/ifcfg-eth0：# vi /etc/sysconfig/network-scripts/ifcfg-eth0将 DEVICE=”eth0” 改成 DEVICE=”eth1” ,将HWADDR=&quot;00:0c:29:8f:89:97&quot; 改成上面的mac地址HWADDR=&quot;00:0c:29:50:bd:17&quot;最后，重启网络：# service network restart或者# /etc/init.d/network restart完成。原文出处 —— 51CTO","tags":[{"name":"Linux","slug":"Linux","permalink":"http://ichenwin.github.io/tags/Linux/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://ichenwin.github.io/tags/虚拟机/"},{"name":"NAT","slug":"NAT","permalink":"http://ichenwin.github.io/tags/NAT/"}]},{"title":"堆和栈","date":"2016-05-12T22:07:25.000Z","path":"2016/05/12/堆和栈/","text":"一、预备知识——程序的内存分配一个由C/C++编译的程序占用的内存分为以下五类： 栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 堆区（heap）— 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。 全局区（静态区）（static）— 全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。 文字常量区 — 常量字符串就是放在这里的。 程序结束后由系统释放 序代码区 — 存放函数体的二进制代码。 二、例子程序 这是一个前辈写的，非常详细123456789101112131415//main.cpp int a = 0; //全局初始化区 char *p1; //全局未初始化区 main() &#123; int b; //栈 char s[] = \"abc\"; //栈 char *p2; //栈 char *p3 = \"123456\"; //123456/0在常量区，p3在栈上。 static int c = 0； //全局（静态）初始化区 p1 = (char *)malloc(10); p2 = (char *)malloc(20); //分配得来得10和20字节的区域就在堆区。 strcpy(p1, \"123456\"); //123456/0放在常量区，编译器可能会将它与p3所指向的\"123456\",优化成一个地方。 &#125; 三、堆和栈的理论知识 申请方式stack: 由系统自动分配。 例如，声明在函数中一个局部变量int b; 系统自动在栈中为b开辟空间heap: 需要程序员自己申请，并指明大小，在c中malloc函数如p1 = (char*)malloc(10);在C++中用new运算符,如p2 = new char[10];但是注意p1、p2本身是在栈中的。 申请后系统的响应栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 申请大小的限制栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 申请效率的比较：栈由系统自动分配，速度较快。但程序员是无法控制的。堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。 堆和栈中的存储内容栈：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。 存取效率的比较char s1[] = “aaaaaaaaaaaaaaa”;char *s2 = “bbbbbbbbbbbbbbbbb”;aaaaaaaaaaa是在运行时刻赋值的；而bbbbbbbbbbb是在编译时就确定的；但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。比如： 12345678910#include void main() &#123; char a = 1; char c[] = \"1234567890\"; char *p = \"1234567890\"; a = c[1]; a = p[1]; return; &#125; 对应的汇编代码: 123456710: a = c[1]; 00401067 8A 4D F1 mov cl,byte ptr [ebp-0Fh] 0040106A 88 4D FC mov byte ptr [ebp-4],cl 11: a = p[1]; 0040106D 8B 55 EC mov edx,dword ptr [ebp-14h] 00401070 8A 42 01 mov al,byte ptr [edx+1] 00401073 88 45 FC mov byte ptr [ebp-4],al 第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，再根据edx读取字符，显然慢了。 小结：堆和栈的区别可以用如下的比喻来看出：使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就 走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自 由度小。使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。 (经典！)","tags":[{"name":"C/C++","slug":"C-C","permalink":"http://ichenwin.github.io/tags/C-C/"}]},{"title":"哈佛大学幸福公开课笔记","date":"2016-04-20T20:36:08.000Z","path":"2016/04/20/哈佛幸福课笔记/","text":"第二课、为什么要学习积极心理学？ 以往，我们常听说的心理学都是针对某些心理问题（比如：抑郁、自卑）而展开的，我们可能回去寻找抑郁的原因，寻找消除抑郁的方法。 以前他们都是从负面去研究心理学，而很少从正面去学习心理学（也就是所谓的“积极心理学”）。而这门哈佛大学幸福公开课就属于积极心理学，它尝试去分析幸福快乐的人、成功的人之所以幸福、成功的原因。 Tal让大家做了个测试，在30秒内数出下图中所有的几何形状的个数： 30秒后，班上有人数出6个，有人数出200个。 然后，Tal问大家“有多少人注意到了图中时钟指示的时间”，“有多少人记的左上角几何的主色调”，“有多少人记的公交车上有几个小孩”。然而大多数人都不记的图中居然还有辆公交车！ 当我门集中注意在某样事物上的时候，其它一切可能都被忽略了。当然，专注并非什么坏事，专注确实很重要，可除了要关注的那一点外，同样有其他重要的事（我们居然不记得图上还有小孩，即使他们在盯着你看）。 接着Tal又给我们举了个栗子：夫妻间，在度完蜜月后，提的最多的一个问题是什么？（度完蜜月之后，不管一个月、一年还是两年，他们会开始问什么问题？）“我们之间怎么了？哪里不对了么？我们怎样去改善关系呢？” 诚然，这是个很重要的问题，可是当我门只关注这一问题时，我们眼里能看到的只有不足，只有感情的裂痕。可事实上除了紧盯着的这一问题，其实还有很多美好的事被我们忽略了。 所以我们关注的问题很关键，当你想着如何提升自己，看着自己的不足，想办法弥补时，这的确是好事。可如果我们只关注自己的不足，紧盯着自己的缺陷，会让我们无视自己的长处。 所以我们要从积极的一面去研究心理学。","tags":[{"name":"心理学","slug":"心理学","permalink":"http://ichenwin.github.io/tags/心理学/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://ichenwin.github.io/tags/学习笔记/"},{"name":"幸福公开课","slug":"幸福公开课","permalink":"http://ichenwin.github.io/tags/幸福公开课/"}]},{"title":"JSON创建和解析的Java实现","date":"2016-04-14T20:36:08.000Z","path":"2016/04/14/JSON解析和创建的Java实现/","text":"JSON概述JSON即JavaScript Object Notation，是JavaScript对象表示法的子集。具有以下特点： 数据放在键值对中； 数据由逗号分隔； 花括号表示对象； 方括号表示数组。 JSON的值可以是： 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true或false） 数组（方括号内） 对象（花括号内） null JSON的基本语法JSON对象JSON对象在花括号中书写，对象可以包含多个键值对，例如：1234&#123; \"firstName\":\"John\", \"lastName\":\"Doe\"&#125; JSON数组JSON数组在方括号中书写，数组中可以包含多个对象，例如：1234567&#123; \"employees\":[ &#123;\"firstName\":\"John\",\"lastName\":\"Doe\"&#125;, &#123;\"firstName\":\"Anna\",\"lastName\":\"Smith\"&#125;, &#123;\"firstName\":\"Peter\",\"lastName\":\"Jones\"&#125; ]&#125; 在以上的实例中，根部的花括号表示这是一个JSON对象，该对象的键是employees，值是一个JSON数组，在这个数组中有3个JSON对象，每个JSON对象之间也使用逗号分隔。 使用Java读取JSON数据在JSON官网我们可以查看到各个语法对JSON的支持，对于Java来说比较成熟的是google-gson。 其maven依赖如下：12345&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.2.4&lt;/version&gt;&lt;/dependency&gt; 现在编写程序解析以下的test.json:123456789&#123; \"cat\":\"it\", \"languages\":[ &#123;\"id\":1,\"ide\":\"Eclipse\",\"name\":\"Java\"&#125;, &#123;\"id\":2,\"ide\":\"Xcode\",\"name\":\"Swift\"&#125;, &#123;\"id\":3,\"ide\":\"Visual Studio\",\"name\":\"C#\"&#125; ], \"pop\":true&#125; 使用Java生成JSON数据生成JSON数据的关键是JSON对象中的add和addProperty两个方法。前者用于向JSON对象中添加数组或者另一个JSON对象，后者用于为JSON对象添加属性。以下的代码将生成上面例子中的test.json。123456789101112131415161718192021222324252627282930313233public void createJSON() throws IOException&#123; JsonObject object = new JsonObject(); // 创建一个JSON对象 object.addProperty(\"cat\", \"it\"); // 为JSON对象添加属性 JsonArray languages = new JsonArray(); // 创建JSON数组 JsonObject language = new JsonObject(); language.addProperty(\"id\", 1); language.addProperty(\"ide\", \"Eclipse\"); language.addProperty(\"name\", \"java\"); languages.add(language); // 将JSON对象添加到数组 language = new JsonObject(); language.addProperty(\"id\", 2); language.addProperty(\"ide\", \"XCode\"); language.addProperty(\"name\", \"Swift\"); languages.add(language); language = new JsonObject(); language.addProperty(\"id\", 3); language.addProperty(\"ide\", \"Visual Studio\"); language.addProperty(\"name\", \"C#\"); languages.add(language); object.add(\"languages\", languages); // 将数组添加到JSON对象 object.addProperty(\"pop\", true); String jsonStr = object.toString(); // 将JSON对象转化成JSON字符串 PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(\"data.json\"))); pw.print(jsonStr); pw.flush(); pw.close();&#125; 以下的代码将解析以上的JSON数据：12345678910111213141516171819public void readJSON() throws Exception&#123; // 创建JSON解析器 JsonParser parser = new JsonParser(); // 使用解析器解析JSON数据，返回值是JsonElement，强制转化为其子类JsonObject类型 JsonObject object = (JsonObject) parser.parse(new FileReader(\"test.json\")); // 使用JsonObject的get(String memeberName)方法返回JsonElement，再使用JsonElement的getAsXXX方法得到真实类型 System.out.println(\"cat = \" + object.get(\"cat\").getAsString()); // 遍历JSON数组 JsonArray languages = object.getAsJsonArray(\"languages\"); for (JsonElement jsonElement : languages) &#123; JsonObject language = jsonElement.getAsJsonObject(); System.out.println(\"id = \" + language.get(\"id\").getAsInt() + \",ide = \" + language.get(\"ide\").getAsString() + \",name = \" + language.get(\"name\").getAsString()); &#125; System.out.println(\"pop = \" + object.get(\"pop\").getAsString());&#125; 转自：segmentfault","tags":[{"name":"JSON","slug":"JSON","permalink":"http://ichenwin.github.io/tags/JSON/"},{"name":"Java","slug":"Java","permalink":"http://ichenwin.github.io/tags/Java/"}]},{"title":"JSON介绍","date":"2016-04-13T21:36:08.000Z","path":"2016/04/13/JSON介绍/","text":"JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。 易于人阅读和编写。同时也易于机器解析和生成。 它基于JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。 这些特性使JSON成为理想的数据交换语言。 JSON建构于两种结构： “名称/值”对的集合（A collection of name/value pairs）。不同的语言中，它被理解为对象（object），纪录（record），结构（struct），字典（dictionary），哈希表（hash table），有键列表（keyed list），或者关联数组 （associative array）。 值的有序列表（An ordered list of values）。在大部分语言中，它被理解为数组（array）。这些都是常见的数据结构。事实上大部分现代计算机语言都以某种形式支持它们。这使得一种数据格式在同样基于这些结构的编程语言之间交换成为可能。 JSON具有以下这些形式： 对象是一个无序的“‘名称/值’对”集合。一个对象以“{”（左括号）开始，“}”（右括号）结束。每个“名称”后跟一个“:”（冒号）；“‘名称/值’ 对”之间使用“,”（逗号）分隔。 数组是值（value）的有序集合。一个数组以“[”（左中括号）开始，“]”（右中括号）结束。值之间使用“,”（逗号）分隔。 (1). 值（value）可以是双引号括起来的字符串（string）、数值(number)、true、false、 null、对象（object）或者数组（array）。这些结构可以嵌套。 1).字符串（string）是由双引号包围的任意数量Unicode字符的集合，使用反斜线转义。一个字符（character）即一个单独的字符串（character string）。字符串（string）与C或者Java的字符串非常相似。 2).数值（number）也与C或者Java的数值非常相似。除去未曾使用的八进制与十六进制格式。除去一些编码细节。空白可以加入到任何符号之间。","tags":[{"name":"JSON","slug":"JSON","permalink":"http://ichenwin.github.io/tags/JSON/"},{"name":"数据交换","slug":"数据交换","permalink":"http://ichenwin.github.io/tags/数据交换/"}]},{"title":"HTTP中GET和POST区别","date":"2016-04-11T21:36:08.000Z","path":"2016/04/11/HTTP中GET和POST比较/","text":"特性 GET POST 后退按钮/刷新 无害 数据会被重新提交（浏览器应该告知用户数据会被重新提交）。 书签 可收藏为书签 不可收藏为书签 编码类型 application/x-www-form-urlencoded application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 历史 参数保留在浏览器历史中。 参数不会保存在浏览器历史中。 对数据长度的限制 是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。 无限制。 对数据类型的限制 只允许 ASCII 字符。 没有限制。也允许二进制数据。 安全性 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分.在发送密码或其他敏感信息时绝不要使用 GET ！ POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。 可见性 数据在 URL 中对所有人都是可见的。 数据不会显示在 URL 中。 HTTP定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认 为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查 ，改 ，增 ，删 4个操作。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。 1.HTTP请求12345HTTP请求一般格式：&lt;request line&gt;&lt;headers&gt;&lt;blank line&gt;[&lt;request-body&gt;] 12345678GET方法实例：GET /books/?sex=man&amp;name=Professional HTTP/1.1Host: www.wrox.comUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)Gecko/20050225 Firefox/1.0.1Connection: Keep-Alive（----此处空一行，可略----）（body，可略） 而对于POST，12345678910POST方法实例：POST / HTTP/1.1Host: www.wrox.comUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)Gecko/20050225 Firefox/1.0.1Content-Type: application/x-www-form-urlencodedContent-Length: 40Connection: Keep-Alive （----此处空一行----）name=Professional%20Ajax&amp;publisher=Wiley (1). 提交过程比较GET提交，请求的数据会附在URL之后（就是把数据放置在请求行（request line）中），以?分割URL和传输数据，多个参数用&amp;连接；例如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0 %E5%A5%BD。Url的编码格式采用的是ASCII码，而不是Unicode，这也就是说你不能在Url中包含任何非ASCII字符，所有非ASCII字符均需要编码再传输。POST提交：把提交的数据放置在是HTTP包的包体中。 因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变。 (2). HTTP中get,post,soap比较1).get：请求参数是作为一个key/value对的序列（查询字符串）附加到URL上的 查询字符串的长度受到web浏览器和web服务器的限制（如IE最多支持2083个字符），不适合传输大型数据集同时，它很不安全2).post：请求参数是在http标题的一个不同部分（名为entity body）传输的，这一部分用来传输表单信息，因此必须将Content-type设置为:application/x-www-form-urlencoded。post设计用来支持web窗体上的用户字段，其参数也是作为key/value对传输。 但是：它不支持复杂数据类型，因为post没有定义传输数据结构的语义和规则。3).soap：是http post的一个专用版本，遵循一种特殊的xml消息格式 Content-type设置为: text/xml 任何数据都可以xml化 2.HTTP响应格式：1234&lt;status line&gt;&lt;headers&gt;&lt;blank line&gt;[&lt;response-body&gt;] 1234567891011121314HTTP响应实例：HTTP/1.1 200 OKContent-Type: text/xml; charset=utf-8Content-Length: length&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;objPlaceOrderResponse xmlns=&quot;https://api.efxnow.com/webservices2.3&quot;&gt;&lt;Success&gt;boolean&lt;/Success&gt;&lt;ErrorDescription&gt;string&lt;/ErrorDescription&gt;&lt;ErrorNumber&gt;int&lt;/ErrorNumber&gt;&lt;CustomerOrderReference&gt;long&lt;/CustomerOrderReference&gt;&lt;OrderConfirmation&gt;string&lt;/OrderConfirmation&gt;&lt;CustomerDealRef&gt;string&lt;/CustomerDealRef&gt;&lt;/objPlaceOrderResponse&gt; 最常用的状态码有：◆200 (OK): 找到了该资源，并且一切正常。◆304 (NOT MODIFIED): 该资源在上次请求之后没有任何修改。这通常用于浏览器的缓存机制。◆401 (UNAUTHORIZED): 客户端无权访问该资源。这通常会使得浏览器要求用户输入用户名和密码，以登录到服务器。◆403 (FORBIDDEN): 客户端未能获得授权。这通常是在401之后输入了不正确的用户名或密码。◆404 (NOT FOUND): 在指定的位置不存在所申请的资源。 本文参考以下博文：HTTP POST GET 本质区别详解","tags":[{"name":"HTTP，GET/POST","slug":"HTTP，GET-POST","permalink":"http://ichenwin.github.io/tags/HTTP，GET-POST/"}]},{"title":"VMware虚拟机NAT设置","date":"2016-03-14T16:36:08.000Z","path":"2016/03/14/VMware虚拟机NAT设置/","text":"VMware虚拟机NAT模式设置1.1 查看虚拟机的网络参数(1). 打开VMware，选择菜单“编辑” 》“虚拟网络编辑器”，如下图： (2). 选中列表中的“VMnet8 NAT”，点击左下角“恢复默认”按钮，恢复默认参数设置。然后点击“NAT设置”按钮，如下图： (3). 记录虚拟网络的子网IP：192.168.58.0、网关IP：192.168.58.21.2 设置物理主机的虚拟网络参数(1). 打开物理主机的网络连接，找到“VMware Network Adapter VMnet8”，设置属性： (2). 设置物理主机的虚拟网络IP地址：192.168.58.X，X在0~255之间，但不可与上面的虚拟网络的子网IP重复。子网掩码、默认网关与上面获取到的虚拟网络的子网掩码、网关保持一致。DNS可设成google的免费DNS：8.8.8.8和8.8.4.4或者阿里的DNS（223.5.5.5和223.6.6.6）。1.3 设置虚拟机CentOS的网络参数（su模式）(1). 配置DNS vi /etc/resolv.conf，也可以使用阿里的DNS（223.5.5.5和223.6.6.6）： (2). 配置网关 vi /etc/sysconfig/network，加入GATEWAY=192.168.58.2： (3). 配置ip地址 vi /etc/sysconfig/network-scripts/ifcfg-eth0，设置IPADDR（IP地址：192.168.58.X，X在0~255之间，但不可与上面的虚拟网络的子网IP、物理机中VMnet8的IP重复）、子网掩码NETMASK、网关GATEWAY： (4). 重启网络服务 service network restart","tags":[{"name":"Linux","slug":"Linux","permalink":"http://ichenwin.github.io/tags/Linux/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://ichenwin.github.io/tags/虚拟机/"},{"name":"NAT","slug":"NAT","permalink":"http://ichenwin.github.io/tags/NAT/"}]},{"title":"Intel Media SDK使用","date":"2016-01-17T14:44:08.000Z","path":"2016/01/17/Intel Media SDK/","text":"这是一篇来自Intel官方的博文，介绍了Intel Media SDK使用方法：Framework for developing applications using Media SDKThis article is geared towards beginner developers in of the Media SDK, which can be found in Intel(R) Media Server Studio or Intel(R) Media SDK for Client. The SDK component in these products is essentially the same and the article below applies to both. Often times, we use the existing samples and tutorials to understand how to develop applications in Media SDK, and modify these samples/tutorials to plug in our own code. Sometimes, it works. But when it is time to add more features to the code or optimize the code, we have to invest a lot more time understanding and re-writing our code. My belief is that if we understand the basic steps that are required to develop an application in Media SDK, the actual time to code itself collapses to simply understanding and using select APIs, and not on coding/debugging the setup part. Enough motivation, let’s begin!Media SDK is a framework that enables developing applications in media by providing APIs for ease of development. These APIs are optimized for the underlying hardware/accelerators and provide good abstractions for most of the heavy-duty media algorithm implementations. So, as a developer, we need to understand the sequence these APIs should be called in to set-up the media pipeline and say go. Much of this article will focus on the former, and also provide some details into the different options available to the developer to add more features. Shown below are the basic structure of a Media SDK application. We will discuss each of these stages in more detail in this article. Now, let us get into details of each of these stages. Initialize SessionThe first part of the set-up stage is initializing the Media SDK session, within which the media pipeline we will define will execute. Sessions use the dispatcher to map function calls to their DLL implementation.12MFXVideoSession session;sts = MFXInit(mfxIMPL impl, mfxVersion ver, MFXVideoSession *session); The MFXInit() function initializes the media session for the implementation specified and for the version available.&quot;mfxIMPL impl&quot; -&gt; Use software, or hardware or best available implementation. We recommend using MFX_IMPL_HARDWARE, or MFX_IMPL_AUTO if you are unsure of the underlying driver support.&quot;mfxVersion ver&quot; -&gt; If you specify 0, it uses the API version from the SDK release with which an application is built. Alternately, you can use MFXQueryVersion function to query for the version. Set ParametersIn this stage, we will specify all the video parameters required for the decode/encode/vpp processing. For each pipeline stage (decode/encode/vpp) in your application, we will populate the mfxVideoParam structure with the appropriate values. We will illustrate this with the following example use-case:1234567Use-case: Input YUV stream -&gt; Pre-processing using VPP -&gt; Encode to H264-&gt; Decode the h264 streamInput Resolution: 352x288Output Resolution: 176x144Required bitrate for encode: 3000 Kbps, Constant BitrateFrame rate: 30 fpsPre-processing: Resize and Denoise filter with window size of 5Video formats: YUV420p and H264 In the table below, the fields filled in are the mandated fields based on the use-case we defined above.In the code snippet below, we show it for generic stage and will point out specifics:12mfxVideoParam Params; // Require one each for decode/encode/vppmemset(&amp;Params, 0, sizeof(Params)); For encode/decode/transcode, the mfxVideoParam::mfxInfoMFX structure needs to be filled in, as it contains variables that define the video properties (for input and output), and variables to control the properties of the encode/decode process. For VPP, the mfxVideoParam::mfxInfoVPP is the main structure that specifies the properties of the input and output VPP frames. Note that the properties specified for the output frames are queried later for validity and support.NOTE: For decoder, you can call the function DecodeHeader that parses the input bit stream and fills the mfxVideoParam structure with appropriate values, such as resolution and frame rate. The application can then pass the resulting mfxVideoParamstructure to the MFXVideoDECODE_Init function for decoder initialization. You can call this function at any time before or after decoder initialization.123sts = mfxDEC.DecodeHeader(mfxBitstream* mfxBS, mfxVideoParam* Params);MSDK_IGNORE_MFX_STS(sts, MFX_WRN_PARTIAL_ACCELERATION); //Ignore this warning message. Indicates SW implementation will be used instead of the HW implementation.MSDK_CHECK_RESULT(sts, MFX_ERR_NONE, sts); Apart from these, some common properties for encode/decode/transcode/VPP in the mfxVideoParam structure are IOPattern, AsyncDepth, NumExtParam and ExtParam. IOPattern is a mandated field for decode, encode and VPP. This parameter itemizes memory access patterns for SDK functions. For example, is the (input,output) access pattern in video memory, system memory or opaque. When using the hardware implementation, it is suggested to use the video memory. AsyncDepth parameter specifies how many asynchronous operations can be performed before the application explicitly synchronizes.External Buffers for added featuresThe NumExtBuffer and ExtParam parameters specify the number of extra configuration structures attached, and the pointer to these configurations respectively. For example, in the use-case above, we want to resize and denoise the input stream before we encode. We use the external buffers to specify these operations, and attach them to the videoParams structure for processing. The ExtendedBufferID enumerator lists the possible operations that can be attached to this structure. simple_4_vpp_resize_denoise_vmem tutorial gives an example of using this structure for de-noising operation.12345678910111213141516171819202122232425// Initialize extended buffer for frame processing// - Denoise VPP denoise filter// - mfxExtVPPDoUse: Define the processing algorithm to be used// - mfxExtVPPDenoise: Denoise configuration// - mfxExtBuffer: Add extended buffers to VPP parameter configurationmfxExtVPPDoUse extDoUse;memset(&amp;extDoUse, 0, sizeof(extDoUse));mfxU32 tabDoUseAlg[1];extDoUse.Header.BufferId = MFX_EXTBUFF_VPP_DOUSE;extDoUse.Header.BufferSz = sizeof(mfxExtVPPDoUse);extDoUse.NumAlg = 1;extDoUse.AlgList = tabDoUseAlg;tabDoUseAlg[0] = MFX_EXTBUFF_VPP_DENOISE;mfxExtVPPDenoise denoiseConfig;memset(&amp;denoiseConfig, 0, sizeof(denoiseConfig));denoiseConfig.Header.BufferId = MFX_EXTBUFF_VPP_DENOISE;denoiseConfig.Header.BufferSz = sizeof(mfxExtVPPDenoise);denoiseConfig.DenoiseFactor = 5; // can be 1-100mfxExtBuffer* ExtBuffer[2];ExtBuffer[0] = (mfxExtBuffer*) &amp;extDoUse;ExtBuffer[1] = (mfxExtBuffer*) &amp;denoiseConfig;VPPParams.NumExtParam = 2;VPPParams.ExtParam = (mfxExtBuffer**) &amp;ExtBuffer[0];// Initialize Media SDK VPPsts = mfxVPP.Init(&amp;VPPParams); With this, we have finished setting the parameters for the media pipeline. You can find more details about the control options and properties in the documentation for Media SDK. Until now, the developer has specified what he wants to achieve with the media pipeline. The SDK may or may not support all the transformations, thus, querying is an important and often ignored step that should follow the set-up. QueryOnce the video parameters are specified in the mfxVideoParam structure, you can Query to check for the validity and SDK support of these parameters. The Query functionality provided by Media SDK is powerful and very useful.The Query functions can be used to check: the implementation supported by the platform - software or hardware (MFXQueryIMPL), version of the SDK (MFXQueryVersion), if the required transformations are supported by the SDK, if not, what are the minimum that can be (Encode_Query. Decode_Query, VPP_query), the number of surfaces required for the transformations (Encode_QueryIOSurf, Decode_QueryIOSurf, VPP_QueryIOSurf).123MFXQueryIMPL(session, &amp;impl); // returns the actual implementation of the sessionMFXQueryVersion(session, &amp;version); //returns the version of the SDK implementationsts = mfxVPP.Query(&amp;Params_in, &amp;Params_out); //*Params_in points to the requested out features, *Param_out points to the features that can be best achieved. If sts is MFX_ERR_NONE, it means requested features can be met. If the status returns warnings for incompatible video parameters, the *param_out is filled with best achievable parameters. Now that we have initialized the session, set the parameters and queried their support, we have to allocate the surface buffers that will be used by the SDK pipeline. Allocate SurfacesOnce we have set the video parameters, our next step is to allocate surfaces for these operations. The QueryIOSurf function returns the minimum and suggested numbers of frame surfaces required for encoding/decoding/VPP initialization and their type. This number depends on multiple parameters such as number of asynchronous operations before synchronization, number of operations in the pipeline stage and buffer sizes. As mentioned above, AsyncDepth is a good parameter to constrain the number of surfaces.1234mfxFrameAllocRequest Request;memset(&amp;Request, 0, sizeof(Request));sts = QueryIOSurf(session, &amp;Params, &amp;Request);mfxU16 numSurfaces = Request.NumFrameSuggested; Now, we proceed with allocation of the surface buffers for the suggested number of surfaces.Allocation of surfaces is very important for performance - The SDK’s best performance comes from using the underlying hardware. Thus, allocating the buffers the SDK operates on in the video memory is highly desirable since this eliminates copying them from the system memory to the video memory. During the session initialization, please use video memory for IO for input and output to specify the usage. And during allocation, use SDK provided alloc functions instead of memset() or new() that would allocate the buffers in the system memory.123456789101112131415/* Using system memory for allocation - NOT RECOMMENDED, since lowers performancemfxU32 surfaceSize = width * height * bitsPerPixel / 8;mfxU8* surfaceBuffers = (mfxU8*) new mfxU8[surfaceSize * numSurfaces];*//* Using video memory for allocation - RECOMMENDED */mfxFrameAllocResponse DecResponse;sts = mfxAllocator.Alloc(mfxAllocator.pthis, &amp;frameAllocRequested, &amp;frameAllocGiven);mfxFrameSurface1** pmfxSurfacesDec = new mfxFrameSurface1 *[numSurfaces];MSDK_CHECK_POINTER(pmfxSurfacesDec, MFX_ERR_MEMORY_ALLOC);for (int i = 0; i &lt; numSurfaces; i++) &#123; pmfxSurfaces[i] = new mfxFrameSurface1; memset(pmfxSurfaces[i], 0, sizeof(mfxFrameSurface1)); memcpy(&amp;(pmfxSurfaces[i]-&gt;Info), &amp;(mfxParams.mfx.FrameInfo), sizeof(mfxFrameInfo)); pmfxSurfaces[i]-&gt;Data.MemId = DecResponse.mids[i]; // MID (memory id) represent one D3D NV12 surface &#125; After the surface allocation, we can now proceed with initializing the encoder/decoder/VPP. NOTE about opaque surfaces: Opaque surfaces, as the name suggests, are managed by the SDK and are not visible or controllable by the developer. These surfaces are best used when the functionality required is basic and concrete (like decoding or encoding) and will not be expanded upon later. As a thumb rule, we always recommend using hardware implementation with video surfaces. Find Free SurfaceWith allocation of surfaces, the set-up part is complete. Yes, it looks tedious, but once you get a hang of it, it is quite intuitive - start the dialogue (initialize session), tell the SDK what you want (set parameters), ask if SDK can do it (query), allocate resources (allocate surfaces) to start doing it! In the following sections, we will touch upon how to start the processing stage and clean-up afterwards.The SDK uses the surfaces allocated and initialized to do the processing. So, to begin processing, use the GetFreeSurface() function to get an input and output surface that is free (not locked by other process) and can be used for the processing. This functionality is as simple as find an unlocked surface for use.1nIndex = GetFreeSurfaceIndex(pmfxSurfaces, numSurfaces); // Find free frame surface After finding the free surface, read the bit stream (for decoder), or the frame (for encoder) into the surface and pass the surface for processing. Processing LoopThe Media SDK provides the developer with synchronous and asynchronous function calls for the processing - be it encode, decode or VPP. As the name suggests, if the function call is synchronous, it is required to wait on sync after every processing function call. In essence, you cannot fire multiple frame processing in parallel. As a rule of thumb, we recommend the use of asynchronous calls to process frames. In a loop that terminates when the input is empty, fire asynchronous functions for either decode/encode/VPP. You can specify the number of asynchronous operations you’d like to perform before synchronizing using the AsyncDepth parameter. This way, you are processing multiple frames in parallel thus improving the performance significantly.123456789101112131415while (MFX_ERR_NONE &lt;= sts || MFX_ERR_MORE_DATA == sts || MFX_ERR_MORE_SURFACE == sts)&#123; /** Asynchronous call handling **/ nTaskIdx = GetFreeTaskIndex(*taskPool, poolSize=AsyncDepth); //Find free taskID if(nTaskIdx == NULL)&#123; sts = session.SyncOperation(pTasks[nFirstSyncTask].syncp, 60000); // Synchronize. Wait until processed frame is ready pTasks[nFirstSyncTask].syncp = NULL; nFirstSyncTask = (nFirstSyncTask + 1) % taskPoolSize; &#125; nIndex = GetFreeSurfaceIndex(pmfxSurfaces, numSurfaces); // Find free frame surface sts = &#123;Decode|Encode|VPP&#125;FrameAsync; /** Synchronous call handling */ if (MFX_ERR_NONE == sts) sts = session.SyncOperation(syncp, 60000); // Synchronize. Wait until processed frame is ready&#125; Drain and CleanupThis stage is similar to the previous Processing Loop, with the exception that the input parameter to the FrameAsync function is NULL, and we are draining the pipeline at this stage. For pseudo-code, all you need to do is replace the first parameter for FrameAsync function with NULL in the while loop above. Once the pipeline draining is done, we deallocate all the buffers used and close the file handles if any.With this we conclude the basic steps for developing using Media SDK. Hope this was helpful. I will add more information as and when I find it.","tags":[{"name":"编解码","slug":"编解码","permalink":"http://ichenwin.github.io/tags/编解码/"},{"name":"视频","slug":"视频","permalink":"http://ichenwin.github.io/tags/视频/"}]},{"title":"视音频数据处理入门 —— RGB、YUV像素数据处理","date":"2016-01-12T19:44:08.000Z","path":"2016/01/12/RGB&YUV/","text":"转自雷神博客：http://blog.csdn.net/leixiaohua1020 ===================================================== 视音频数据处理入门系列文章： 视音频数据处理入门：RGB、YUV像素数据处理 视音频数据处理入门：PCM音频采样数据处理 视音频数据处理入门：H.264视频码流解析 视音频数据处理入门：AAC音频码流解析 视音频数据处理入门：FLV封装格式解析 视音频数据处理入门：UDP-RTP协议解析 ===================================================== 有段时间没有写博客了，这两天写起博客来竟然感觉有些兴奋，仿佛找回了原来的感觉。前一阵子在梳理以前文章的时候，发现自己虽然总结了各种视音频应用程序，却还缺少一个适合无视音频背景人员学习的“最基础”的程序。因此抽时间将以前写过的代码整理成了一个小项目。这个小项目里面包含了一系列简单的函数，可以对RGB/YUV视频像素数据、PCM音频采样数据、H.264视频码流、AAC音频码流、FLV封装格式数据、UDP/RTP协议数据进行简单处理。这个项目的一大特点就是没有使用任何的第三方类库，完全借助于C语言的基本函数实现了功能。通过对这些代码的学习，可以让初学者迅速掌握视音频数据的基本格式。有关上述几种格式的介绍可以参考文章《 [总结]视音频编解码技术零基础学习方法 》。 从这篇文章开始打算写6篇文章分别记录上述6种不同类型的视音频数据的处理方法。本文首先记录第一部分即RGB/YUV视频像素数据的处理方法。视频像素数据在视频播放器的解码流程中的位置如下图所示。 本文分别介绍如下几个RGB/YUV视频像素数据处理函数：分离YUV420P像素数据中的Y、U、V分量分离YUV444P像素数据中的Y、U、V分量将YUV420P像素数据去掉颜色（变成灰度图）将YUV420P像素数据的亮度减半将YUV420P像素数据的周围加上边框生成YUV420P格式的灰阶测试图计算两个YUV420P像素数据的PSNR分离RGB24像素数据中的R、G、B分量将RGB24格式像素数据封装为BMP图像将RGB24格式像素数据转换为YUV420P格式像素数据生成RGB24格式的彩条测试图 本文中的RGB/YUV文件需要使用RGB/YUV播放器才能查看。YUV播放器种类比较多，例如 YUV Player Deluxe ，或者开源播放器（参考文章《 修改了一个YUV/RGB播放器 》）等。 函数列表(1) 分离YUV420P像素数据中的Y、U、V分量本程序中的函数可以将YUV420P数据中的Y、U、V三个分量分离开来并保存成三个文件。函数的代码如下所示。 /** * Split Y, U, V planes in YUV420P file. * @param url Location of Input YUV file. * @param w Width of Input YUV file. * @param h Height of Input YUV file. * @param num Number of frames to process. * */ int simplest_yuv420_split(char *url, int w, int h,int num) { FILE *fp=fopen(url,&quot;rb+&quot;); FILE *fp1=fopen(&quot;output_420_y.y&quot;,&quot;wb+&quot;); FILE *fp2=fopen(&quot;output_420_u.y&quot;,&quot;wb+&quot;); FILE *fp3=fopen(&quot;output_420_v.y&quot;,&quot;wb+&quot;); unsigned char *pic=(unsigned char *)malloc(w*h*3/2); for(int i=0;i&lt;num;i++){ fread(pic,1,w*h*3/2,fp); //Y fwrite(pic,1,w*h,fp1); //U fwrite(pic+w*h,1,w*h/4,fp2); //V fwrite(pic+w*h*5/4,1,w*h/4,fp3); } free(pic); fclose(fp); fclose(fp1); fclose(fp2); fclose(fp3); return 0; } 调用上面函数的方法如下所示。 simplest_yuv420_split(&quot;lena_256x256_yuv420p.yuv&quot;,256,256,1); 从代码可以看出，如果视频帧的宽和高分别为w和h，那么一帧YUV420P像素数据一共占用wh3/2 Byte的数据。其中前whByte存储Y，接着的wh1/4 Byte存储U，最后wh*1/4 Byte存储V。上述调用函数的代码运行后，将会把一张分辨率为256x256的名称为lena_256x256_yuv420p.yuv的YUV420P格式的像素数据文件分离成为三个文件： output_420_y.y：纯Y数据，分辨率为256x256。 output_420_u.y：纯U数据，分辨率为128x128。 output_420_v.y：纯V数据，分辨率为128x128。 注：本文中像素的采样位数一律为8bit。由于1Byte=8bit，所以一个像素的一个分量的采样值占用1Byte。 程序输入的原图如下所示。 lena_256x256_yuv420p.yuv 程序输出的三个文件的截图如下图所示。在这里需要注意输出的U、V分量在YUV播放器中也是当做Y分量进行播放的。 output_420_y.y output_420_u.y和output_420_v.y (2)分离YUV444P像素数据中的Y、U、V分量本程序中的函数可以将YUV444P数据中的Y、U、V三个分量分离开来并保存成三个文件。函数的代码如下所示。 /** * Split Y, U, V planes in YUV444P file. * @param url Location of YUV file. * @param w Width of Input YUV file. * @param h Height of Input YUV file. * @param num Number of frames to process. * */ int simplest_yuv444_split(char *url, int w, int h,int num) { FILE *fp=fopen(url,&quot;rb+&quot;); FILE *fp1=fopen(&quot;output_444_y.y&quot;,&quot;wb+&quot;); FILE *fp2=fopen(&quot;output_444_u.y&quot;,&quot;wb+&quot;); FILE *fp3=fopen(&quot;output_444_v.y&quot;,&quot;wb+&quot;); unsigned char *pic=(unsigned char *)malloc(w*h*3); for(int i=0;i&lt;num;i++){ fread(pic,1,w*h*3,fp); //Y fwrite(pic,1,w*h,fp1); //U fwrite(pic+w*h,1,w*h,fp2); //V fwrite(pic+w*h*2,1,w*h,fp3); } free(pic); fclose(fp); fclose(fp1); fclose(fp2); fclose(fp3); return 0; } 调用上面函数的方法如下所示。 simplest_yuv444_split(&quot;lena_256x256_yuv444p.yuv&quot;,256,256,1); 从代码可以看出，如果视频帧的宽和高分别为w和h，那么一帧YUV444P像素数据一共占用wh3 Byte的数据。其中前wh Byte存储Y，接着的whByte存储U，最后w*h Byte存储V。上述调用函数的代码运行后，将会把一张分辨率为256x256的名称为lena_256x256_yuv444p.yuv的YUV444P格式的像素数据文件分离成为三个文件： output_444_y.y：纯Y数据，分辨率为256x256。output_444_u.y：纯U数据，分辨率为256x256。output_444_v.y：纯V数据，分辨率为256x256。 输入的原图如下所示。 输出的三个文件的截图如下图所示。 output_444_y.y output_444_u.y output_444_v.y (3) 将YUV420P像素数据去掉颜色（变成灰度图）本程序中的函数可以将YUV420P格式像素数据的彩色去掉，变成纯粹的灰度图。函数的代码如下。 /** * Convert YUV420P file to gray picture * @param url Location of Input YUV file. * @param w Width of Input YUV file. * @param h Height of Input YUV file. * @param num Number of frames to process. */ int simplest_yuv420_gray(char *url, int w, int h,int num) { FILE *fp=fopen(url,&quot;rb+&quot;); FILE *fp1=fopen(&quot;output_gray.yuv&quot;,&quot;wb+&quot;); unsigned char *pic=(unsigned char *)malloc(w*h*3/2); for(int i=0;i&lt;num;i++){ fread(pic,1,w*h*3/2,fp); //Gray memset(pic+w*h,128,w*h/2); fwrite(pic,1,w*h*3/2,fp1); } free(pic); fclose(fp); fclose(fp1); return 0; } 调用上面函数的方法如下所示。 simplest_yuv420_gray(&quot;lena_256x256_yuv420p.yuv&quot;,256,256,1); 从代码可以看出，如果想把YUV格式像素数据变成灰度图像，只需要将U、V分量设置成128即可。这是因为U、V是图像中的经过偏置处理的色度分量。色度分量在偏置处理前的取值范围是-128至127，这时候的无色对应的是“0”值。经过偏置后色度分量取值变成了0至255，因而此时的无色对应的就是128了。上述调用函数的代码运行后，将会把一张分辨率为256x256的名称为lena_256x256_yuv420p.yuv的YUV420P格式的像素数据文件处理成名称为output_gray.yuv的YUV420P格式的像素数据文件。输入的原图如下所示。 处理后的图像如下所示。 (4)将YUV420P像素数据的亮度减半本程序中的函数可以通过将YUV数据中的亮度分量Y的数值减半的方法，降低图像的亮度。函数代码如下所示。 /** * Halve Y value of YUV420P file * @param url Location of Input YUV file. * @param w Width of Input YUV file. * @param h Height of Input YUV file. * @param num Number of frames to process. */ int simplest_yuv420_halfy(char *url, int w, int h,int num) { FILE *fp=fopen(url,&quot;rb+&quot;); FILE *fp1=fopen(&quot;output_half.yuv&quot;,&quot;wb+&quot;); unsigned char *pic=(unsigned char *)malloc(w*h*3/2); for(int i=0;i&lt;num;i++){ fread(pic,1,w*h*3/2,fp); //Half for(int j=0;j&lt;w*h;j++){ unsigned char temp=pic[j]/2; //printf(&quot;%d,\\n&quot;,temp); pic[j]=temp; } fwrite(pic,1,w*h*3/2,fp1); } free(pic); fclose(fp); fclose(fp1); return 0; } 调用上面函数的方法如下所示。 simplest_yuv420_halfy(&quot;lena_256x256_yuv420p.yuv&quot;,256,256,1); 从代码可以看出，如果打算将图像的亮度减半，只要将图像的每个像素的Y值取出来分别进行除以2的工作就可以了。图像的每个Y值占用1Byte，取值范围是0至255，对应C语言中的unsigned char数据类型。上述调用函数的代码运行后，将会把一张分辨率为256x256的名称为lena_256x256_yuv420p.yuv的YUV420P格式的像素数据文件处理成名称为output_half.yuv的YUV420P格式的像素数据文件。输入的原图如下所示。 处理后的图像如下所示。 (5)将YUV420P像素数据的周围加上边框本程序中的函数可以通过修改YUV数据中特定位置的亮度分量Y的数值，给图像添加一个“边框”的效果。函数代码如下所示。 /** * Add border for YUV420P file * @param url Location of Input YUV file. * @param w Width of Input YUV file. * @param h Height of Input YUV file. * @param border Width of Border. * @param num Number of frames to process. */ int simplest_yuv420_border(char *url, int w, int h,int border,int num) { FILE *fp=fopen(url,&quot;rb+&quot;); FILE *fp1=fopen(&quot;output_border.yuv&quot;,&quot;wb+&quot;); unsigned char *pic=(unsigned char *)malloc(w*h*3/2); for(int i=0;i&lt;num;i++){ fread(pic,1,w*h*3/2,fp); //Y for(int j=0;j&lt;h;j++){ for(int k=0;k&lt;w;k++){ if(k&lt;border||k&gt;(w-border)||j&lt;border||j&gt;(h-border)){ pic[j*w+k]=255; //pic[j*w+k]=0; } } } fwrite(pic,1,w*h*3/2,fp1); } free(pic); fclose(fp); fclose(fp1); return 0; } 调用上面函数的方法如下所示。 simplest_yuv420_border(&quot;lena_256x256_yuv420p.yuv&quot;,256,256,20,1); 从代码可以看出，图像的边框的宽度为border，本程序将距离图像边缘border范围内的像素的亮度分量Y的取值设置成了亮度最大值255。上述调用函数的代码运行后，将会把一张分辨率为256x256的名称为lena_256x256_yuv420p.yuv的YUV420P格式的像素数据文件处理成名称为output_border.yuv的YUV420P格式的像素数据文件。输入的原图如下所示。 处理后的图像如下所示。 (6) 生成YUV420P格式的灰阶测试图本程序中的函数可以生成一张YUV420P格式的灰阶测试图。函数代码如下所示。 /** * Generate YUV420P gray scale bar. * @param width Width of Output YUV file. * @param height Height of Output YUV file. * @param ymin Max value of Y * @param ymax Min value of Y * @param barnum Number of bars * @param url_out Location of Output YUV file. */ int simplest_yuv420_graybar(int width, int height,int ymin,int ymax,int barnum,char *url_out) { int barwidth; float lum_inc; unsigned char lum_temp; int uv_width,uv_height; FILE *fp=NULL; unsigned char *data_y=NULL; unsigned char *data_u=NULL; unsigned char *data_v=NULL; int t=0,i=0,j=0; barwidth=width/barnum; lum_inc=((float)(ymax-ymin))/((float)(barnum-1)); uv_width=width/2; uv_height=height/2; data_y=(unsigned char *)malloc(width*height); data_u=(unsigned char *)malloc(uv_width*uv_height); data_v=(unsigned char *)malloc(uv_width*uv_height); if((fp=fopen(url_out,&quot;wb+&quot;))==NULL){ printf(&quot;Error: Cannot create file!&quot;); return -1; } //Output Info printf(&quot;Y, U, V value from picture&apos;s left to right:\\n&quot;); for(t=0;t&lt;(width/barwidth);t++){ lum_temp=ymin+(char)(t*lum_inc); printf(&quot;%3d, 128, 128\\n&quot;,lum_temp); } //Gen Data for(j=0;j&lt;height;j++){ for(i=0;i&lt;width;i++){ t=i/barwidth; lum_temp=ymin+(char)(t*lum_inc); data_y[j*width+i]=lum_temp; } } for(j=0;j&lt;uv_height;j++){ for(i=0;i&lt;uv_width;i++){ data_u[j*uv_width+i]=128; } } for(j=0;j&lt;uv_height;j++){ for(i=0;i&lt;uv_width;i++){ data_v[j*uv_width+i]=128; } } fwrite(data_y,width*height,1,fp); fwrite(data_u,uv_width*uv_height,1,fp); fwrite(data_v,uv_width*uv_height,1,fp); fclose(fp); free(data_y); free(data_u); free(data_v); return 0; } 调用上面函数的方法如下所示。 simplest_yuv420_graybar(640, 360,0,255,10,&quot;graybar_640x360.yuv&quot;); 从源代码可以看出，本程序一方面通过灰阶测试图的亮度最小值ymin，亮度最大值ymax，灰阶数量barnum确定每一个灰度条中像素的亮度分量Y的取值。另一方面还要根据图像的宽度width和图像的高度height以及灰阶数量barnum确定每一个灰度条的宽度。有了这两方面信息之后，就可以生成相应的图片了。上述调用函数的代码运行后，会生成一个取值范围从0-255，一共包含10个灰度条的YUV420P格式的测试图。测试图的内容如下所示。 从程序也可以得到从左到右10个灰度条的Y、U、V取值，如下所示。 Y U V 0128 128 28 128 128 56 128 128 85 128 128 113 128 128 141 128 128 170 128 128 198 128 128 226 128 128 255 128 128 (7)计算两个YUV420P像素数据的PSNRPSNR是最基本的视频质量评价方法。本程序中的函数可以对比两张YUV图片中亮度分量Y的PSNR。函数的代码如下所示。 /** * Calculate PSNR between 2 YUV420P file * @param url1 Location of first Input YUV file. * @param url2 Location of another Input YUV file. * @param w Width of Input YUV file. * @param h Height of Input YUV file. * @param num Number of frames to process. */ int simplest_yuv420_psnr(char *url1,char *url2,int w,int h,int num) { FILE *fp1=fopen(url1,&quot;rb+&quot;); FILE *fp2=fopen(url2,&quot;rb+&quot;); unsigned char *pic1=(unsigned char *)malloc(w*h); unsigned char *pic2=(unsigned char *)malloc(w*h); for(int i=0;i&lt;num;i++){ fread(pic1,1,w*h,fp1); fread(pic2,1,w*h,fp2); double mse_sum=0,mse=0,psnr=0; for(int j=0;j&lt;w*h;j++){ mse_sum+=pow((double)(pic1[j]-pic2[j]),2); } mse=mse_sum/(w*h); psnr=10*log10(255.0*255.0/mse); printf(&quot;%5.3f\\n&quot;,psnr); fseek(fp1,w*h/2,SEEK_CUR); fseek(fp2,w*h/2,SEEK_CUR); } free(pic1); free(pic2); fclose(fp1); fclose(fp2); return 0; } 调用上面函数的方法如下所示。 simplest_yuv420_psnr(&quot;lena_256x256_yuv420p.yuv&quot;,&quot;lena_distort_256x256_yuv420p.yuv&quot;,256,256,1); 对于8bit量化的像素数据来说，PSNR的计算公式如下所示。 上述公式中mse的计算公式如下所示。 其中M，N分别为图像的宽高，xij和yij分别为两张图像的每一个像素值。PSNR通常用于质量评价，就是计算受损图像与原始图像之间的差别，以此来评价受损图像的质量。本程序输入的两张图像的对比图如下图所示。其中左边的图像为原始图像，右边的图像为受损图像。 经过程序计算后得到的PSNR取值为26.693。PSNR取值通常情况下都在20-50的范围内，取值越高，代表两张图像越接近，反映出受损图像质量越好。 (8) 分离RGB24像素数据中的R、G、B分量本程序中的函数可以将RGB24数据中的R、G、B三个分量分离开来并保存成三个文件。函数的代码如下所示。 /** * Split R, G, B planes in RGB24 file. * @param url Location of Input RGB file. * @param w Width of Input RGB file. * @param h Height of Input RGB file. * @param num Number of frames to process. * */ int simplest_rgb24_split(char *url, int w, int h,int num) { FILE *fp=fopen(url,&quot;rb+&quot;); FILE *fp1=fopen(&quot;output_r.y&quot;,&quot;wb+&quot;); FILE *fp2=fopen(&quot;output_g.y&quot;,&quot;wb+&quot;); FILE *fp3=fopen(&quot;output_b.y&quot;,&quot;wb+&quot;); unsigned char *pic=(unsigned char *)malloc(w*h*3); for(int i=0;i&lt;num;i++){ fread(pic,1,w*h*3,fp); for(int j=0;j&lt;w*h*3;j=j+3){ //R fwrite(pic+j,1,1,fp1); //G fwrite(pic+j+1,1,1,fp2); //B fwrite(pic+j+2,1,1,fp3); } } free(pic); fclose(fp); fclose(fp1); fclose(fp2); fclose(fp3); return 0; } 调用上面函数的方法如下所示。 simplest_rgb24_split(&quot;cie1931_500x500.rgb&quot;, 500, 500,1); 从代码可以看出，与YUV420P三个分量分开存储不同，RGB24格式的每个像素的三个分量是连续存储的。一帧宽高分别为w、h的RGB24图像一共占用wh3Byte的存储空间。RGB24格式规定首先存储第一个像素的R、G、B，然后存储第二个像素的R、G、B…以此类推。类似于YUV420P的存储方式称为Planar方式，而类似于RGB24的存储方式称为Packed方式。上述调用函数的代码运行后，将会把一张分辨率为500x500的名称为cie1931_500x500.rgb的RGB24格式的像素数据文件分离成为三个文件： output_r.y：R数据，分辨率为256x256。output_g.y：G数据，分辨率为256x256。 output_b.y：B数据，分辨率为256x256。 输入的原图是一张标准的CIE 1931色度图。该色度图右下为红色，上方为绿色，左下为蓝色，如下所示。 R数据图像如下所示。 G数据图像如下所示。 B数据图像如下所示。 (9)将RGB24格式像素数据封装为BMP图像BMP图像内部实际上存储的就是RGB数据。本程序实现了对RGB像素数据的封装处理。通过本程序中的函数，可以将RGB数据封装成为一张BMP图像。 /** * Convert RGB24 file to BMP file * @param rgb24path Location of input RGB file. * @param width Width of input RGB file. * @param height Height of input RGB file. * @param url_out Location of Output BMP file. */ int simplest_rgb24_to_bmp(const char *rgb24path,int width,int height,const char *bmppath) { typedef struct { long imageSize; long blank; long startPosition; }BmpHead; typedef struct { long Length; long width; long height; unsigned short colorPlane; unsigned short bitColor; long zipFormat; long realSize; long xPels; long yPels; long colorUse; long colorImportant; }InfoHead; int i=0,j=0; BmpHead m_BMPHeader={0}; InfoHead m_BMPInfoHeader={0}; char bfType[2]={&apos;B&apos;,&apos;M&apos;}; int header_size=sizeof(bfType)+sizeof(BmpHead)+sizeof(InfoHead); unsigned char *rgb24_buffer=NULL; FILE *fp_rgb24=NULL,*fp_bmp=NULL; if((fp_rgb24=fopen(rgb24path,&quot;rb&quot;))==NULL){ printf(&quot;Error: Cannot open input RGB24 file.\\n&quot;); return -1; } if((fp_bmp=fopen(bmppath,&quot;wb&quot;))==NULL){ printf(&quot;Error: Cannot open output BMP file.\\n&quot;); return -1; } rgb24_buffer=(unsigned char *)malloc(width*height*3); fread(rgb24_buffer,1,width*height*3,fp_rgb24); m_BMPHeader.imageSize=3*width*height+header_size; m_BMPHeader.startPosition=header_size; m_BMPInfoHeader.Length=sizeof(InfoHead); m_BMPInfoHeader.width=width; //BMP storage pixel data in opposite direction of Y-axis (from bottom to top). m_BMPInfoHeader.height=-height; m_BMPInfoHeader.colorPlane=1; m_BMPInfoHeader.bitColor=24; m_BMPInfoHeader.realSize=3*width*height; fwrite(bfType,1,sizeof(bfType),fp_bmp); fwrite(&amp;m_BMPHeader,1,sizeof(m_BMPHeader),fp_bmp); fwrite(&amp;m_BMPInfoHeader,1,sizeof(m_BMPInfoHeader),fp_bmp); //BMP save R1|G1|B1,R2|G2|B2 as B1|G1|R1,B2|G2|R2 //It saves pixel data in Little Endian //So we change &apos;R&apos; and &apos;B&apos; for(j =0;j&lt;height;j++){ for(i=0;i&lt;width;i++){ char temp=rgb24_buffer[(j*width+i)*3+2]; rgb24_buffer[(j*width+i)*3+2]=rgb24_buffer[(j*width+i)*3+0]; rgb24_buffer[(j*width+i)*3+0]=temp; } } fwrite(rgb24_buffer,3*width*height,1,fp_bmp); fclose(fp_rgb24); fclose(fp_bmp); free(rgb24_buffer); printf(&quot;Finish generate %s!\\n&quot;,bmppath); return 0; return 0; } 调用上面函数的方法如下所示。 simplest_rgb24_to_bmp(&quot;lena_256x256_rgb24.rgb&quot;,256,256,&quot;output_lena.bmp&quot;); 通过代码可以看出，改程序完成了主要完成了两个工作：1)将RGB数据前面加上文件头。2)将RGB数据中每个像素的“B”和“R”的位置互换。 BMP文件是由BITMAPFILEHEADER、BITMAPINFOHEADER、RGB像素数据共3个部分构成，它的结构如下图所示。 BITMAPFILEHEADER BITMAPINFOHEADER RGB像素数据 其中前两部分的结构如下所示。在写入BMP文件头的时候给其中的每个字段赋上合适的值就可以了。 typedef struct tagBITMAPFILEHEADER { unsigned short int bfType; //位图文件的类型，必须为BM unsigned long bfSize; //文件大小，以字节为单位 unsigned short int bfReserverd1; //位图文件保留字，必须为0 unsigned short int bfReserverd2; //位图文件保留字，必须为0 unsigned long bfbfOffBits; //位图文件头到数据的偏移量，以字节为单位 }BITMAPFILEHEADER; typedef struct tagBITMAPINFOHEADER { long biSize; //该结构大小，字节为单位 long biWidth; //图形宽度以象素为单位 long biHeight; //图形高度以象素为单位 short int biPlanes; //目标设备的级别，必须为1 short int biBitcount; //颜色深度，每个象素所需要的位数 short int biCompression; //位图的压缩类型 long biSizeImage; //位图的大小，以字节为单位 long biXPelsPermeter; //位图水平分辨率，每米像素数 long biYPelsPermeter; //位图垂直分辨率，每米像素数 long biClrUsed; //位图实际使用的颜色表中的颜色数 long biClrImportant; //位图显示过程中重要的颜色数 }BITMAPINFOHEADER; BMP采用的是小端（Little Endian）存储方式。这种存储方式中“RGB24”格式的像素的分量存储的先后顺序为B、G、R。由于RGB24格式存储的顺序是R、G、B，所以需要将“R”和“B”顺序作一个调换再进行存储。 下图为输入的RGB24格式的图像lena_256x256_rgb24.rgb。 下图分封装为BMP格式后的图像output_lena.bmp。封装后的图像使用普通的看图软件就可以查看。 (10)将RGB24格式像素数据转换为YUV420P格式像素数据本程序中的函数可以将RGB24格式的像素数据转换为YUV420P格式的像素数据。函数的代码如下所示。 unsigned char clip_value(unsigned char x,unsigned char min_val,unsigned char max_val) { if(x&gt;max_val){ return max_val; }else if(x&lt;min_val){ return min_val; }else{ return x; } } //RGB to YUV420 bool RGB24_TO_YUV420(unsigned char *RgbBuf,int w,int h,unsigned char *yuvBuf) { unsigned char*ptrY, *ptrU, *ptrV, *ptrRGB; memset(yuvBuf,0,w*h*3/2); ptrY = yuvBuf; ptrU = yuvBuf + w*h; ptrV = ptrU + (w*h*1/4); unsigned char y, u, v, r, g, b; for (int j = 0; j&lt;h;j++){ ptrRGB = RgbBuf + w*j*3 ; for (int i = 0;i&lt;w;i++){ r = *(ptrRGB++); g = *(ptrRGB++); b = *(ptrRGB++); y = (unsigned char)( ( 66 * r + 129 * g + 25 * b + 128) &gt;&gt; 8) + 16 ; u = (unsigned char)( ( -38 * r - 74 * g + 112 * b + 128) &gt;&gt; 8) + 128 ; v = (unsigned char)( ( 112 * r - 94 * g - 18 * b + 128) &gt;&gt; 8) + 128 ; *(ptrY++) = clip_value(y,0,255); if (j%2==0&amp;&amp;i%2 ==0){ *(ptrU++) =clip_value(u,0,255); } else{ if (i%2==0){ *(ptrV++) =clip_value(v,0,255); } } } } return true; } /** * Convert RGB24 file to YUV420P file * @param url_in Location of Input RGB file. * @param w Width of Input RGB file. * @param h Height of Input RGB file. * @param num Number of frames to process. * @param url_out Location of Output YUV file. */ int simplest_rgb24_to_yuv420(char *url_in, int w, int h,int num,char *url_out) { FILE *fp=fopen(url_in,&quot;rb+&quot;); FILE *fp1=fopen(url_out,&quot;wb+&quot;); unsigned char *pic_rgb24=(unsigned char *)malloc(w*h*3); unsigned char *pic_yuv420=(unsigned char *)malloc(w*h*3/2); for(int i=0;i&lt;num;i++){ fread(pic_rgb24,1,w*h*3,fp); RGB24_TO_YUV420(pic_rgb24,w,h,pic_yuv420); fwrite(pic_yuv420,1,w*h*3/2,fp1); } free(pic_rgb24); free(pic_yuv420); fclose(fp); fclose(fp1); return 0; } 调用上面函数的方法如下所示。 simplest_rgb24_to_yuv420(&quot;lena_256x256_rgb24.rgb&quot;,256,256,1,&quot;output_lena.yuv&quot;); 从源代码可以看出，本程序实现了RGB到YUV的转换公式： Y= 0.299R+0.587G+0.114*B U=-0.147R-0.289G+0.463*B V= 0.615R-0.515G-0.100*B 在转换的过程中有以下几点需要注意：1) RGB24存储方式是Packed，YUV420P存储方式是Packed。2) U，V在水平和垂直方向的取样数是Y的一半 转换前的RGB24格式像素数据lena_256x256_rgb24.rgb的内容如下所示。 转换后的YUV420P格式的像素数据output_lena.yuv的内容如下所示。 (11)生成RGB24格式的彩条测试图本程序中的函数可以生成一张RGB24格式的彩条测试图。函数代码如下所示。 /** * Generate RGB24 colorbar. * @param width Width of Output RGB file. * @param height Height of Output RGB file. * @param url_out Location of Output RGB file. */ int simplest_rgb24_colorbar(int width, int height,char *url_out) { unsigned char *data=NULL; int barwidth; char filename[100]={0}; FILE *fp=NULL; int i=0,j=0; data=(unsigned char *)malloc(width*height*3); barwidth=width/8; if((fp=fopen(url_out,&quot;wb+&quot;))==NULL){ printf(&quot;Error: Cannot create file!&quot;); return -1; } for(j=0;j&lt;height;j++){ for(i=0;i&lt;width;i++){ int barnum=i/barwidth; switch(barnum){ case 0:{ data[(j*width+i)*3+0]=255; data[(j*width+i)*3+1]=255; data[(j*width+i)*3+2]=255; break; } case 1:{ data[(j*width+i)*3+0]=255; data[(j*width+i)*3+1]=255; data[(j*width+i)*3+2]=0; break; } case 2:{ data[(j*width+i)*3+0]=0; data[(j*width+i)*3+1]=255; data[(j*width+i)*3+2]=255; break; } case 3:{ data[(j*width+i)*3+0]=0; data[(j*width+i)*3+1]=255; data[(j*width+i)*3+2]=0; break; } case 4:{ data[(j*width+i)*3+0]=255; data[(j*width+i)*3+1]=0; data[(j*width+i)*3+2]=255; break; } case 5:{ data[(j*width+i)*3+0]=255; data[(j*width+i)*3+1]=0; data[(j*width+i)*3+2]=0; break; } case 6:{ data[(j*width+i)*3+0]=0; data[(j*width+i)*3+1]=0; data[(j*width+i)*3+2]=255; break; } case 7:{ data[(j*width+i)*3+0]=0; data[(j*width+i)*3+1]=0; data[(j*width+i)*3+2]=0; break; } } } } fwrite(data,width*height*3,1,fp); fclose(fp); free(data); return 0; } 调用上面函数的方法如下所示。 simplest_rgb24_colorbar(640, 360,&quot;colorbar_640x360.rgb&quot;); 从源代码可以看出，本程序循环输出“白黄青绿品红蓝黑”8种颜色的彩条。这8种颜色的彩条的R、G、B取值如下所示。 颜色 (R, G, B) 白 (255, 255, 255) 黄 (255, 255, 0) 青 ( 0, 255, 255) 绿 ( 0, 255, 0) 品 (255, 0, 255) 红 (255, 0, 0) 蓝 ( 0, 0, 255) 黑 ( 0, 0, 0) 生成的图像截图如下所示。 下载 Simplest mediadata test 项目主页 SourceForge： https://sourceforge.net/projects/simplest-mediadata-test/ Github： https://github.com/leixiaohua1020/simplest_mediadata_test 开源中国： http://git.oschina.net/leixiaohua1020/simplest_mediadata_test CSDN下载地址： http://download.csdn.net/detail/leixiaohua1020/9422409 本项目包含如下几种视音频数据解析示例：(1)像素数据处理程序。包含RGB和YUV像素格式处理的函数。(2)音频采样数据处理程序。包含PCM音频采样格式处理的函数。(3)H.264码流分析程序。可以分离并解析NALU。(4)AAC码流分析程序。可以分离并解析ADTS帧。(5)FLV封装格式分析程序。可以将FLV中的MP3音频码流分离出来。 (6)UDP-RTP协议分析程序。可以将分析UDP/RTP/MPEG-TS数据包。 雷霄骅 (Lei Xiaohua)leixiaohua1020@126.comhttp://blog.csdn.net/leixiaohua1020","tags":[{"name":"编解码","slug":"编解码","permalink":"http://ichenwin.github.io/tags/编解码/"},{"name":"视频","slug":"视频","permalink":"http://ichenwin.github.io/tags/视频/"}]},{"title":"图文详解YUV420","date":"2016-01-09T14:44:08.000Z","path":"2016/01/09/图文详解YUV420/","text":"最近接触到YUV格式，这篇文章讲得很透彻图文详解YUV420数据格式-by azraelly，转载至此。YUV格式有两大类：planar和packed。 对于planar的YUV格式，先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V。 对于packed的YUV格式，每个像素点的Y,U,V是连续交叉存储的。 一、定义与分类 YUV，分为三个分量，“Y”表示明亮度（Luminance或Luma），也就是灰度值；而“U”和“V”表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。 与我们熟知的RGB类似，YUV也是一种颜色编码方法，主要用于电视系统以及模拟视频领域，它将亮度信息（Y）与色彩信息（UV）分离，没有UV信息一样可以显示完整的图像，只不过是黑白的，这样的设计很好地解决了彩色电视机与黑白电视的兼容问题。并且，YUV不像RGB那样要求三个独立的视频信号同时传输，所以用YUV方式传送占用极少的频宽。 YUV码流的存储格式其实与其采样的方式密切相关，主流的采样方式有三种，YUV4:4:4，YUV4:2:2，YUV4:2:0，关于其详细原理，可以通过网上其它文章了解，这里我想强调的是如何根据其采样格式来从码流中还原每个像素点的YUV值，因为只有正确地还原了每个像素点的YUV值，才能通过YUV与RGB的转换公式提取出每个像素点的RGB值，然后显示出来。 用三个图来直观地表示采集的方式吧，以黑点表示采样该像素点的Y分量，以空心圆圈表示采用该像素点的UV分量。先记住下面这段话，以后提取每个像素的YUV分量会用到。 1. YUV 4:4:4采样，每一个Y对应一组UV分量。2. YUV 4:2:2采样，每两个Y共用一组UV分量。3. YUV 4:2:0采样，每四个Y共用一组UV分量。二、存储方式 下面我用图的形式给出常见的YUV码流的存储方式，并在存储方式后面附有取样每个像素点的YUV数据的方法，其中，Cb、Cr的含义等同于U、V。 1、 YUVY 格式 （属于YUV422） YUYV为YUV422采样的存储格式中的一种，相邻的两个Y共用其相邻的两个Cb、Cr，分析，对于像素点Y&#39;00、Y&#39;01而言，其Cb、Cr的值均为 Cb00、Cr00，其他的像素点的YUV取值依次类推。 ２、UYVY 格式 （属于YUV422） UYVY格式也是YUV422采样的存储格式中的一种，只不过与YUYV不同的是UV的排列顺序不一样而已，还原其每个像素点的YUV值的方法与上面一样。 3、YUV422P（属于YUV422） YUV422P也属于YUV422的一种，它是一种Planar模式，即平面模式，并不是将YUV数据交错存储，而是先存放所有的Y分量，然后存储所有的U（Cb）分量，最后存储所有的V（Cr）分量，如上图所示。其每一个像素点的YUV值提取方法也是遵循YUV422格式的最基本提取方法，即两个Y共用一个UV。比如，对于像素点Y’00、Y’01 而言，其Cb、Cr的值均为 Cb00、Cr00。 4、YV12，YU12格式（属于YUV420） YU12和YV12属于YUV420格式，也是一种Planar模式，将Y、U、V分量分别打包，依次存储。其每一个像素点的YUV数据提取遵循YUV420格式的提取方式，即4个Y分量共用一组UV。注意，上图中，Y&#39;00、Y&#39;01、Y&#39;10、Y&#39;11共用Cr00、Cb00，其他依次类推。 5、NV12、NV21（属于YUV420） NV12和NV21属于YUV420格式，是一种two-plane模式，即Y和UV分为两个Planar，但是UV（CbCr）为交错存储，而不是分为三个Planar。其提取方式与上一种类似，即Y&#39;00、Y&#39;01、Y&#39;10、Y&#39;11共用Cr00、Cb00。YUV420 planar数据， 以720×488大小图象YUV420 planar为例，其存储格式是： 共大小为(720×480×3&gt;&gt;1)字节，分为三个部分:Y,U和V Y分量： (720×480)个字节 U(Cb)分量：(720×480&gt;&gt;2)个字节 V(Cr)分量：(720×480&gt;&gt;2)个字节三个部分内部均是行优先存储，三个部分之间是Y,U,V 顺序存储。即YUV数据的 0－－720×480字节是Y分量值， 720×480－－720×480×5/4字节是U分量 720×480×5/4 －－720×480×3/2字节是V分量。 三、4:2: 2和4:2:0 转换： 最简单的方式：YUV4:2:2 —&gt; YUV4:2:0 Y不变，将U和V信号值在行(垂直方向)在进行一次隔行抽样。 YUV4:2:0 —&gt; YUV4:2:2 Y不变，将U和V信号值的每一行分别拷贝一份形成连续两行数据。在YUV420中，一个像素点对应一个Y，一个4X4的小方块对应一个U和V。对于所有YUV420图像，它们的Y值排列是完全相同的，因为只有Y的图像就是灰度图像。YUV420sp与YUV420p的数据格式它们的UV排列在原理上是完全不同的。420p它是先把U存放完后，再存放V，也就是说UV它们是连续的。而420sp它是UV、UV这样交替存放的。(见下图) 有了上面的理论，我就可以准确的计算出一个YUV420在内存中存放的大小。 width hight =Y（总和） U = Y / 4 V = Y / 4所以YUV420 数据在内存中的长度是 width hight * 3 / 2，假设一个分辨率为8X4的YUV图像，它们的格式如下图：YUV420sp格式如下图：YUV420p数据格式如下图： 旋转90度的算法:123456789101112131415161718192021222324public static void rotateYUV240SP(byte[] src,byte[] des,int width,int height)&#123; int wh = width * height; //旋转Y int k = 0; for(int i=0;i&lt;width;i++) &#123; for(int j=0;j&lt;height;j++) &#123; des[k] = src[width*j + i]; k++; &#125; &#125; for(int i=0;i&lt;width;i+=2) &#123; for(int j=0;j&lt;height/2;j++) &#123; des[k] = src[wh+ width*j + i]; des[k+1]=src[wh + width*j + i+1]; k+=2; &#125; &#125;&#125; YV12和I420的区别一般来说，直接采集到的视频数据是RGB24的格式，RGB24一帧的大小size＝width×heigth×3Bytes，RGB32的size＝width×heigth×4 Bytes，如果是I420（即YUV标准格式4：2：0）的数据量是 size＝width×heigth×1.5 Bytes。 在采集到RGB24数据后，需要对这个格式的数据进行第一次压缩。即将图像的颜色空间由RGB2YUV。因为，X264在进行编码的时候需要标准的YUV（4：2：0）。但是这里需要注意的是，虽然YV12也是（4：2：0），但是YV12和I420的却是不同的，在存储空间上面有些区别。如下： YV12 ： 亮度（行×列） ＋ U（行×列/4) + V（行×列/4） I420 ： 亮度（行×列） ＋ V（行×列/4) + U（行×列/4） 可以看出，YV12和I420基本上是一样的，就是UV的顺序不同。 继续我们的话题，经过第一次数据压缩后RGB24－&gt;YUV（I420）。这样，数据量将减少一半。同样，如果是RGB24－&gt;YUV（YV12），也是减少一半。但是，虽然都是一半，如果是YV12的话效果就有很大损失。然后，经过X264编码后，数据量将大大减少。将编码后的数据打包，通过RTP实时传送。到达目的地后，将数据取出，进行解码。完成解码后，数据仍然是YUV格式的，所以，还需要一次转换，这样windows的驱动才可以处理，就是YUV2RGB24。YUY2 是 4:2:2 [Y0 U0 Y1 V0]yuv420p 和 YUV420的区别 在存储格式上有区别：yuv420p：yyyyyyyy uu vv yuv420： yuv yuv yuv YUV420P，Y，U，V三个分量都是平面格式，分为I420和YV12。I420格式和YV12格式的不同处在U平面和V平面的位置不同。在I420格式中，U平面紧跟在Y平面之后，然后才是V平面（即：YUV）；但YV12则是相反（即：YVU）。 YUV420SP, Y分量平面格式，UV打包格式, 即NV12。 NV12与NV21类似，U 和 V 交错排列,不同在于UV顺序。I420: YYYYYYYY UU VV =&gt;YUV420PYV12: YYYYYYYY VV UU =&gt;YUV420PNV12: YYYYYYYY UVUV =&gt;YUV420SPNV21: YYYYYYYY VUVU =&gt;YUV420SP","tags":[{"name":"编解码","slug":"编解码","permalink":"http://ichenwin.github.io/tags/编解码/"},{"name":"视频","slug":"视频","permalink":"http://ichenwin.github.io/tags/视频/"}]},{"title":"宏offsetof(TYPE, MEMBER)解释","date":"2016-01-09T10:42:25.000Z","path":"2016/01/09/宏offsetof(TYPE, MEMBER)/","text":"最近看代码，看到一处宏，#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)一眼没看出原理，搜索一番，再仔细分析才看懂，该宏的作用就是求出MEMBER在TYPE中的偏移量。也就是成员变量MEMBER的入口地址先分析一下这个宏的运行机理，一共4步： ((TYPE *)0) 将零转型为TYPE类型指针; ((TYPE *)0)-&gt;MEMBER 访问结构中的数据成员; &amp;(((TYPE *)0)-&gt;MEMBER)取出数据成员的地址; 这个实现相当于获取到了 MEMBER 成员相对于其所在结构体的偏移，也就是其在对应结构体中的什么位置。 (size_t)(&amp;(((TYPE*)0)-&gt;MEMBER))结果转换类型。巧妙之处在于将0转 换成(TYPE*)，结构以内存空间首地址0作为起始地址，则成员地址自然为偏移地址；&amp;操作如果是对一个表达式，而不是一个标识符，会取消操作，而不是添加。比如&amp;*a，会直接把a的地址求出来，不会访问*a。&amp;a-&gt;member，会把访问a-&gt;member的操作取消，只会计算出a-&gt;member的地址 转自宏offsetof(TYPE, MEMBER)解释","tags":[{"name":"C/C++","slug":"C-C","permalink":"http://ichenwin.github.io/tags/C-C/"}]},{"title":"CIF、4CIF等格式说明","date":"2015-12-20T18:04:08.000Z","path":"2015/12/20/CIF、4CIF等格式说明/","text":"什么是CIF/QCIF/4CIF/WCIF/W4CIF/D1 CIF (Common Intermediate Format 或 Common Interchange Format)， 也叫作 FCIF (Full Common Intermediate Format)，是视频会议中常使用的视频传输格式，分辨率为352 x 288 ，视频传输帧率可达30 frame/s。CIF格式可以非常方便地转为PAL和NTSC格式。 CIF可以定义一种以352*288为分辨率（PAL）、帧率为30000/1001（约29.97）（NTSC）、YCbCr 4:2:0的视频流。 QCIF，即Quarter CIF。 SQCIF (Sub Quarter CIF，有时也写作subQCIF) 格式 分辨率 SQCIF 128x96 QCIF 176x144 SCIF 256x192 SIF(525) 352x240 CIF/SIF(625) 352x288 4SIF(525) 704x480 4CIF/4SIF(625)/D1 704x576 16CIF 1408x1152 DCIF 528x384 图解如下：其中视频监控行业，HALF D1（704x288）、D1（704x576）WCIF(512x288)、W4CIF(1024x576)","tags":[{"name":"编解码","slug":"编解码","permalink":"http://ichenwin.github.io/tags/编解码/"},{"name":"视频","slug":"视频","permalink":"http://ichenwin.github.io/tags/视频/"}]},{"title":"给hexo博客添加背景音乐","date":"2015-11-01T10:04:08.000Z","path":"2015/11/01/hexo添加背景音乐/","text":"获取外链 获取到的外链长这样：123&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;http://music.163.com/outchain/player?type=2&amp;id=1993765&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt; 将它稍作修改：12345&lt;% if (theme.background_music.enable)&#123; %&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=200 height=86 src=&lt;%= theme.background_music.src %&gt;&gt;&lt;/iframe&gt;&lt;% &#125; %&gt; 其中的width、height都可以根据自己需求修改播放器宽高。src部分被改为了主题jacman配置文件中的变量名，并且在iframe外面套了一层if判断。同时将src后的链接提取出来：1&quot;http://music.163.com/outchain/player?type=2&amp;id=1993765&amp;auto=1&amp;height=66&quot; 修改E:\\Hexo\\themes\\jacman\\_config.yml，在文件末尾加入如下部分，其中src后面部分就是上一步src后的链接，以后要换背景音乐只需替换这一链接就行了。123background_music: enable: true src: &quot;http://music.163.com/outchain/player?type=2&amp;id=1993765&amp;auto=1&amp;height=66&quot; 修改E:\\Hexo\\themes\\jacman\\layout\\_partial\\sidebar.ejs，在&lt;div id=&quot;asidepart&quot;&gt;后面插入第一步修改后的代码：123&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;http://music.163.com/outchain/player?type=2&amp;id=1993765&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;","tags":[{"name":"博客 CSS","slug":"博客-CSS","permalink":"http://ichenwin.github.io/tags/博客-CSS/"}]},{"title":"CSS选择器","date":"2015-10-14T22:40:25.000Z","path":"2015/10/14/CSS选择器/","text":"类选择器(class selectors)（1）. 多个元素之间可以共用（2）. 以英文句号（.）开头 ID选择器(ID selectors)（1）. 每个元素唯一指定，在文档中必须唯一（2）. 以井号（#）开头（3）. 选择器优先级ID选择器&gt;类选择器&gt;标签选择器","tags":[{"name":"HTML","slug":"HTML","permalink":"http://ichenwin.github.io/tags/HTML/"}]},{"title":"HTML简介","date":"2015-10-04T22:40:25.000Z","path":"2015/10/04/HTML简介/","text":"HTML简介HTML 是一种标记语言（markup language）。它告诉浏览器如何显示内容。HTML把内容（文字，图片，语言，影片等等）和「presentation」（这个内容是如何显示，比如文字用什么颜色显示等等）分开。HTML使用预先定义的元素集合来识别内容形态。 元素包含一个以上的标记来包含或者表达内容。标记利用尖括号表示，而结束标记（用来指示内容尾端）则在前面加上斜线。举例来说，段落元素包含起始标记“&lt;p&gt;”和结束标记“&lt;/p&gt;”。下面的例子展示一个包含HTML段落元素的段落1&lt;p&gt;My dog ate all the guacamole.&lt;/p&gt; &lt;abbr&gt;标签&lt;abbr&gt; 标签指示简称或缩写，比如 “WWW” 或 “NATO”，当鼠标移至该缩写是可以显示其全称。栗子：1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;A tiny document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Main heading in my document&lt;/h1&gt; &lt;p&gt;Look Ma,I am coding &lt;abbr title=\"Hyper Text Markup Language\"&gt;HTML&lt;/abbr&gt;.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 效果：","tags":[{"name":"HTML","slug":"HTML","permalink":"http://ichenwin.github.io/tags/HTML/"}]},{"title":"回调函数","date":"2015-09-07T21:42:25.000Z","path":"2015/09/07/回调函数/","text":"关于回调函数，知友常溪玲是这样回答的： 到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货(不是营业员打电话通知你，是营业员直接帮你买了，送到你家。 by傅奕然)。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。下面是一个回调函数的示例程序：123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;typedef void(*CallbackFun)(int); //void类型的函数指针void printWelcome(int len) //自己的实现函数要和函数指针形式相一致&#123; printf(\"欢迎欢迎 -- %d\\n\", len);&#125;void printGoodbye(int len)&#123; printf(\"送客送客 -- %d\\n\", len);&#125;void testfun_API(int times, CallbackFun pFun) //模拟API函数或DLL函数&#123; int i; for (i = 0; i &lt; times; ++i) &#123; pFun(i); &#125; printf(\"\\n我不知道你是迎客还是送客!\\n\\n\");&#125;void main(void)&#123; testfun_API(10, printWelcome); //call API testfun_API(10, printGoodbye); printWelcome(5);&#125; 运行结果：","tags":[{"name":"C/C++","slug":"C-C","permalink":"http://ichenwin.github.io/tags/C-C/"}]},{"title":"大小端字节序的转换","date":"2015-08-27T22:07:25.000Z","path":"2015/08/27/大小端字节序的转换/","text":"本文参考了Ocean’s Caprice的《［c/c++ ］字节序与大小端转换》 今天在移植OspServer过程中出现文件传输停滞的问题。经导师指点，可能是字节序的问题。因为目标机PowerPC采用的是大端字节(big-endian)存储方式，而平时一般Intel和AMD的CPU采用的都是小端字节(little-endian)。 大端字节序，也叫网络字节序，一般规定不同系统间通信一律采用网络字节序。所谓大端字节序，就是将数据高位存放在内存低位。也就是内存的地址是由低到高的顺序，而数据的字节却是由高到低。如一个long型数据0x12345678，它在内存中存储方式： 内存地址 数据位 0x0029f458 0x12 0x0029f459 0x34 0x0029f45a 0x56 0x0029f45b 0x78 小端字节序，内存的地址是由低到高的顺序，数据的字节也是由低到高。0x12345678在内存中存储方式： 内存地址 数据位 0x0029f458 0x78 0x0029f459 0x56 0x0029f45a 0x34 0x0029f45b 0x12 整数字节序转换12345678//对应int32大小的成员 的转换 范例 int32_t swapInt32(int32_t value) &#123; return ((value &amp; 0x000000FF) &lt;&lt; 24) | ((value &amp; 0x0000FF00) &lt;&lt; 8) | ((value &amp; 0x00FF0000) &gt;&gt; 8) | ((value &amp; 0xFF000000) &gt;&gt; 24); &#125; 浮点数字节序转换 浮点数的内部结构相对比较复杂，但仍然可以把浮点数当作整数转换字节序，因为字节始终是字节，可以使用c++的reinterpret_cast操作把浮点数诠释为整数，这称为类型双关（type_punning），或者使用一个简便的方法是使用union。12345678910111213union intWithFloat &#123; int32_t m_i32; float m_f32; &#125; float swapFloat32(float value) &#123; intWithFloat i; i.m_i32 = value; i.m_f32 = swapInt32(i.m_i32) return i.m_f32; &#125;","tags":[{"name":"C/C++","slug":"C-C","permalink":"http://ichenwin.github.io/tags/C-C/"}]},{"title":"大教堂与集市","date":"2015-06-12T11:39:55.000Z","path":"2015/06/12/大教堂与集市/","text":"Brooks定律：在一个已经延期的项目上增加人手，只会让项目更加延期。随着开发人员数目的增长，项目复杂度和沟通成本按照人数的平方增长，而工作成果只会呈线性增长。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://ichenwin.github.io/tags/Linux/"},{"name":"黑客","slug":"黑客","permalink":"http://ichenwin.github.io/tags/黑客/"},{"name":"技术提升","slug":"技术提升","permalink":"http://ichenwin.github.io/tags/技术提升/"}]},{"title":"谷歌推荐的技术提升指南","date":"2015-06-07T09:47:17.000Z","path":"2015/06/07/谷歌推荐的技术提升指南/","text":"译者注：本文是翻译自 Google Career 的一篇职业规划指南，需阅读原文的请自备墙梯。以下是译文： 打好扎实的计算机科学基础对于成为一个成功的软件工程师是非常重要的。本指南主要关于如何提升自己的技术能力，非常适合学生用于制定教学课程，当然这里提供的网络资源，并不意味着就可以完全取代现有的课程，正式的课程安排还是要学的(除非你不想拿到毕业证书)。 学术学习的推荐 ●CS课程入门 计算机科学课程导论，介绍编码的基本知识。 在线资源：Udacity – intro to CS course, Coursera – Computer Science 101 至少要会一种面向对象的编程语言：C ++、Java或Python 初级在线资源： Coursera – Learn to Program: The Fundamentals, MIT Intro to Programming in Java,Google’s Python Class, Coursera – Introduction to Python, Python Open Source E-Book 中级在线资源： Udacity’s Design of Computer Programs, Coursera – Learn to Program: Crafting Quality Code, Coursera – Programming Languages, Brown University – Introduction to Programming Languages ●了解其他的编程语言 注：添加到你的知识库中——JavaScript、CSS &amp; HTML、Ruby、PHP、C、Perl、shell script、Lisp和Scheme 在线资源： w3school.com – HTML Tutorial, Codecademy, Udacity – Mobile Web Development, Udacity – HTML5 Game Development ●测试代码 注：学习如何捕捉bug，创建测试，破坏软件 在线资源： Udacity – Software Testing Methods, Udacity – Software Debugging ●培养逻辑推理和学习数学离散知识 在线资源： MIT Mathematics for Computer Science, Coursera – Introduction to Logic, Coursera – Linear and Discrete Optimization, Coursera – Probabilistic Graphical Models, Coursera – Game Theory ●深刻理解算法和数据结构 注：了解基本的数据类型(栈、队列和包)，排序算法(快速排序、归并排序、堆排序)，数据结构(二叉搜索树、红黑树、哈希表)，和算法的时间复杂度. 在线资源： MIT Introduction to Algorithms, Coursera Introduction to Algorithms Part 1 &amp; Part 2, List of Algorithms, List of Data Structures, 书籍：The Algorithm Design Manual ●深刻理解操作系统 在线资源：UC Berkeley Computer Science 162 ●学习UX设计 在线资源：Udacity – UX Design for Mobile Developers ●学习人工智能 在线资源： Stanford University - Introduction to Robotics, Natural Language Processing, Machine Learning ●学习如何构建编译器 在线资源：Coursera – Compilers ●了解密码学 在线资源：Coursera – Cryptography, Udacity – Applied Cryptography ●了解并行编程 在线资源： Coursera – Heterogeneous Parallel Programming ●尝试课外项目 注：可以是创建和维护网站，构建服务器，或打造机器人。 在线资源： Apache List of Projects, Google Summer of Code, Google Developer Group ●阅读和理解来自于一个大型系统(代码库)的代码，追踪文档并调试。 注：可以在GitHub上阅读他人的代码，研究他们的项目。 在线资源：GitHub, Kiln ●与其他程序员一起开发项目 注：这能有助于你提高团队合作能力，同时还可以取长补短。 ●实践算法知识和编码技能 注：通过类似于CodeJam和ACM国际大学生程序设计竞赛的方式来实践自己的算法知识。 在线资源：CodeJam, ACM ICPC ●成为助教 这有利于增强和巩固自我的学科知识。 实习 注：提前申请实习。比如说美国的实习期是在夏天的5至9月，那么你应该提前几个月就开始申请。 译文链接：http://www.codeceo.com/article/google-guide-for-technical-development.html 英文原文：Guide for Technical Development 翻译作者：码农网 – 小峰","tags":[{"name":"技术提升","slug":"技术提升","permalink":"http://ichenwin.github.io/tags/技术提升/"}]},{"title":"用MBRFix卸载Linux","date":"2015-04-18T08:17:25.000Z","path":"2015/04/18/用MBRFix卸载Linux/","text":"Win7和Linux双系统的情况下，卸载Linux，需修改MBR，方法有二： 将Windows的安装盘放入计算机以后，重启计算机，进入Windows安装程序，随后，进入恢复控制台，输入命令fixmbr即可。 如果没有Windows安装盘，就可以用MBRFix工具进行修复。MBRFix工具修复MBR很方便，先进入cmd命令窗口，然后进入mbrfix工具所在的目录（用cd命令），然后输入命令 MbrFix /drive 0 fixmbr ，再确认一下即可。重启以后你会发现，没有了Linux，直接可以进入Windows了。 附一：MbrFix命令12345678910MbrFix /drive &lt;num&gt; driveinfo Display drive informationMbrFix /drive &lt;num&gt; listpartitions Display partition informationMbrFix /drive &lt;num&gt; savembr &lt;file&gt; Save MBR and partitions to fileMbrFix /drive &lt;num&gt; restorembr &lt;file&gt; Restore MBR and partitions from fileMbrFix /drive &lt;num&gt; fixmbr Update MBR code to W2K/XP/2003MbrFix /drive &lt;num&gt; clean Delete partitions in MBRMbrFix /drive &lt;num&gt; readsignature &#123;/byte&#125; Read disk signature from MBRMbrFix /drive &lt;num&gt; generatesignature Generate disk signature in MBRMbrFix /drive &lt;num&gt; readstate Read state from byte 0x1b0 in MBRMbrFix /drive &lt;num&gt; writestate &lt;state&gt; Write state to byte 0x1b0 in MBR 附件二：MBRFix下载：链接: http://pan.baidu.com/s/1bn6O78r密码: y3mk","tags":[{"name":"Linux","slug":"Linux","permalink":"http://ichenwin.github.io/tags/Linux/"}]},{"title":"Python笔记","date":"2015-04-10T14:07:25.000Z","path":"2015/04/10/Python笔记/","text":"列表 BIF，即“Built-in Funcation”，内置函数，比如：len()isinstance(movies,list) #检查movies是否是列表 多行注释——使用三重引号123\"\"\"这是一段python注释，它可以写成多行。 like this.\"\"\" 函数模块 PyPI(Pie-Pie)——Python Package Index上传时需在模块目录下创建一文件setup.py，其内容如下：12345678910from distutils.core import setupsetup( name = 'cw-nester', version = '1.3.0', py_modules = ['cw-nester'], author = 'iChenwin', author_email= 'ichenwin@gmail.com', url = 'http://ichenwin.github.io', description = 'A simple printer of nested lists', ) 生成模块命令，在模块所在目录下执行：D:\\python27\\python.exe setup.py sdist然后要上传到PyPI，第一次使用须填用户密码，命令如下：D:\\python27\\python.exe setup.py register最后上传：D:\\python27\\python.exe setup.py upload 导入模块/函数的方法：1.import module，此方法使用函数是要带上模块名称：如：math.sqrt(4)2.from module import function，此方法可直接调用函数名，但可能覆盖原有函数 主命名空间是：__main__BIF的命名空间是：__builtins__，一般会自动包含在Python程序 ‘sys’模块，其中的‘stdout’，“标准输出”，即显示到屏幕上，比如：‘print(*obj,sep=&#39;&#39;,end=&#39;\\n&#39;,file=sys.stdout)’ python2中要想让print不换行，可以这样(在末尾加逗号)：print &#39;你要打印的字符&#39;,比如你要打印“1234”，可以这样：12print '12',print '34' 而在python3中，则可以这样实现：12print('12',end='')print('34') 异常 异常处理： 1234567try: data = open('sketch.txt') ...expect IOError: print 'The file is missing'finally: data.close() 文件操作BIF：a. 打开文件，参数是文件路径的字符串：data = open(&#39;sketch.txt&#39;)可以用‘with’语句，从此无需手动‘data.close()’文件，用法： 12with open('sketch.txt','r') as myfile: myfile.readline() 其中第二个参数可以是： 读——‘r’， 覆盖写——‘w’， 追加——‘a’， 写和读（不清除）——‘w+’， 二进制读——‘rb’， 二进制写——‘wb’b. 一次读取一行，光标自动移至下一行：data.readline()c. 方法，跳至文件某一行：data.seek(0)d. 关闭文件：data.close()e. 切割字符串方法，参数一切割标识符，可选参数二切割段数（填1，只认第一个切割符，切为两段）：each_line.split(&#39;:&#39;,1)f. 查找指定子字符串的方法，没找到则返回‘-1’，找到则返回所在索引：each_line.find(&#39;:&#39;) 保存数据至文件 保存到文件，print()的‘file’参数：print(each_line,file=filename) 导入pickle模块a.“腌制”，将数据以特有的二进制格式保存到磁盘：pickle.dump()b.“解除研制”，从磁盘以二进制格式恢复数据：pickle.load() 除去字符串首尾不想要的空格：string.strip() 当前作用域内的变量集合：locals()用来检验文件是否正常打开：if data in locals():","tags":[{"name":"Python","slug":"Python","permalink":"http://ichenwin.github.io/tags/Python/"}]},{"title":"Java笔记","date":"2015-04-01T19:11:25.000Z","path":"2015/04/01/Java笔记/","text":"类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。 方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。 源文件名：源文件名必须和类名相同。 主方法入口：所有的Java 程序由public static void main(String args[])方法开始执行。 一个类可以包含以下类型变量：(1).局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。(2).成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。(3).类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。` 每个类都有构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。 Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。(1).byte：byte数据类型是8位、有符号的，以二进制补码表示的整数；最小值是-128（-2^7）；最大值是127（2^7-1）；默认值是0；byte类型用在大型数组中节约空间，主要代替整数，因为byte变量占用的空间只有int类型的四分之一；例子：byte a = 100，byte b = -50。(2).short：short数据类型是16位、有符号的以二进制补码表示的整数最小值是-32768（-2^15）；最大值是32767（2^15 - 1）；Short数据类型也可以像byte那样节省空间。一个short变量是int型变量所占空间的二分之一；默认值是0；例子：short s = 1000，short r = -20000。(3).int：int数据类型是32位、有符号的以二进制补码表示的整数；最小值是-2,147,483,648（-2^31）；最大值是2,147,485,647（2^31 - 1）；一般地整型变量默认为int类型；默认值是0；例子：int a = 100000, int b = -200000。(4).long：long数据类型是64位、有符号的以二进制补码表示的整数；最小值是-9,223,372,036,854,775,808（-2^63）；最大值是9,223,372,036,854,775,807（2^63 -1）；这种类型主要使用在需要比较大整数的系统上；默认值是0L；例子： long a = 100000L，int b = -200000L。(5).float：float数据类型是单精度、32位、符合IEEE 754标准的浮点数；float在储存大型浮点数组的时候可节省内存空间；默认值是0.0f；浮点数不能用来表示精确的值，如货币；例子：float f1 = 234.5f。(6).double：double数据类型是双精度、64位、符合IEEE 754标准的浮点数；浮点数的默认类型为double类型；double类型同样不能表示精确的值，如货币；默认值是0.0f；例子：double d1 = 123.4。(7).boolean：boolean数据类型表示一位的信息；只有两个取值：true和false；这种类型只作为一种标志来记录true/false情况；默认值是false；例子：boolean one = true。(8).char：char类型是一个单一的16位Unicode字符；最小值是’\\u0000’（即为0）；最大值是’\\uffff’（即为65,535）；char数据类型可以储存任何字符；例子：char letter = ‘A’。","tags":[{"name":"Java","slug":"Java","permalink":"http://ichenwin.github.io/tags/Java/"}]},{"title":"Fedora 20安装fcitx输入法","date":"2015-03-18T20:01:00.000Z","path":"2015/03/18/Fedora 20安装fcitx输入法 /","text":"转自： http://yanue.net/post-140.html 为方便操作，先以用root账户登录系统 1、先卸载系统自带的Ibus输入法 1. sudo yum remove ibus 2. gsettings set org.gnome.settings-daemon.plugins.keyboard active false 2、安装Fcitx输入法a. 全部安装 1. sudo yum install fcitx* b. 当然，其实没必要全部安装： 1. yum list &apos;*fcitx*&apos; 装上fcitx fcitx-devel fcitx-configtool 就可以了 1. yum install fcitx fcitx-devel fcitx-configtool 3、配置一下Fcitx、在~/.bashrc中添加:如下内容 1. export GTK_IM_MODULE=fcitx 2. export QT_IM_MODULE=fcitx 3. export XMODIFIERS=&quot;@im=fcitx&quot; 4、注销或重启后完成安装上面步骤完成之后其实就可以使用Fcitx输入法","tags":[{"name":"Linux","slug":"Linux","permalink":"http://ichenwin.github.io/tags/Linux/"}]},{"title":"HTML笔记","date":"2015-03-17T09:40:25.000Z","path":"2015/03/17/HTML笔记/","text":"1. 创建有序或无序列表 （Making ordered and unordered lists）&lt;ol&gt;&lt;/ol&gt; &lt;ul&gt;&lt;/ul&gt; 2. 改变文本大小、颜色、字体 （Changing font size, color and type）style=&quot;font-size: 16px; color:blue; font-family:Arial&quot; 3. 改变背景颜色 （Changing the background color）style=&quot;background-color: yellow&quot; 4. 文本对齐 （Aligning the text）style=&quot;text-align: left/center/right&quot; 5. 文本加粗 （Strong words!）&lt;strong&gt;&lt;/strong&gt; 6. 斜体（强调） （Emphasize words!）&lt;em&gt;&lt;/em&gt; 7. 注释 （Comments）&lt;！-- This is a comment! --&gt; 8. 表格 （Table）&lt;table&gt;&lt;/table&gt;","tags":[{"name":"HTML","slug":"HTML","permalink":"http://ichenwin.github.io/tags/HTML/"}]},{"title":"我的求职之路：9个offer，12家公司，35场面试，最终谷歌","date":"2014-12-18T17:28:00.000Z","path":"2014/12/18/我的求职之路：9个offer，12家公司，35场面试，最终谷歌 /","text":"作者：Luc（写于2012年） 1，简介 毕业答辩搞定，总算可以闲一段时间，把这段求职经历写出来，也作为之前三个半月的求职的回顾。 首先说说我拿到的offer情况： 微软，3面-&gt;终面，搞定 百度，3面-&gt;终面，口头offer 搜狗，2面，悲剧 腾讯，1面，悲剧 布丁移动，3面，搞定 涂鸦游戏，3面，搞定 友盟，3面-&gt;CEO面，搞定 雅虎，4面-&gt;终面，搞定 微策略，2面，悲剧 人民搜索，3面-&gt;终面，搞定 人人，2面+终面+Special面，搞定 Google，7面，搞定 求职经历分为定位、准备、简历、笔试和面试这五个部分，大家挑感兴趣的看就成。 我的求职经历适用但不限于码农，不适用与企事业单位（据说是完全不同的考察标准和流程）。废话比较多，大家耐心忍受，有什么问题可以跟帖提问。 2，定位 教育经历：本科在大连某工科院校，由于GPA比较惨烈+挂科，所以没保成研，毕业后修了一年英语双学位，然后到帝都计算机职业教育学院接受再教育。 技术能力：属于半码农半产品的类型，代码编的过去（搞过compiler），也有一些拿的出手的产品（几十w的用户量），一句话描述：几十w代码+几十w用户的Coder。 专业能力：非ACM出身，算法拙计但基础扎实。由于单身所以看了N多书（CS+心理+经管+历史），扯淡能力强大，碰到非专业的各种秒杀，碰到专业各种拙计。 实习经历：大四在一家ds公司实习过一年，攒了不少代码量；后来在MS断断续续的待了一年多，虽说是打酱油，但在众大神的光环笼罩下，水平至少提了三个档。 目标公司：由于百度给我的印象实在很差，而MS给我的印象又实在很好，所有就有了下面的排名： 外企（Google、MS、Yahoo等）&gt;国内互联网（阿里、腾讯、百度、网易等）&gt;企事业单位（基本不考虑） 3，准备 经常在论坛里看到各种求职抱怨贴，其实在抱怨前应该仔细想一想，为了求职，你付出了多少？看到人家找工作找的顺找的爽，有没有想过人家背地里付出了多少努力和心血？别拿官二代和富二代啥的说事，真ds只会拿一堆自身以外的理由掩饰自己的懒惰。 不要认为求职就是发个简历等面试通知，对于大神来说不用发简历牛逼公司也会围着你转，对于ds来说就是预则立不预则废，中国缺什么就是不缺人，不下功夫准备很有可能连个P都没有。 其实很多ds就是怕预也废所以干脆不准备直接上，这样搞不定的话，就有借口说不是自己蠢而是自己没准备，可以捍卫自己的智商高地不被侵犯。身边有不少这样的实例，典型的死要面子活受罪，活该你找不到工作。 我的微软mentor曾提到过，我的实习面试表现一般，但后来表现出的动手能力大大超出之前面试的预估，而有些面试表现很出色，问题对答如流的选手，入职之后反而不是很理想，至少没有达到面试时发挥出的水准。 这说明一个问题，就是笔试面试，准备和不准备会差异很大。如果你的简历不是那么NB，那就只能靠笔试和面试的加分撑场面。身边经常有同学纳闷这样代码都编不利索的傻屌都能进MS为什么我不能进，答案往往很简单：人家比你多准备了一个月。平时电脑上写程序可能很利索，笔试面试时在纸上写写试试你就知道什么叫拙计。 IT公司的笔试和面试的题量都不大（相对于企事业单位和银行动辄上百道选择题的题量，算是很少），一般十几道选择题，三四道大题就算题量很大。但计算机的东西实在又是太多，程序设计、数据结构、算法设计、操作系统、体系结构、编译原理、数据库、软件工程等分支，编译的话太难（一千个码农里也没几个人能在纸上写一个最基础的递归下降LLParser），软件工程、体系结构、数据库这些太水（不是说这些分支没用，而是它们很难考察，尤其对应届生来说这些都是些文字游戏，比如说面向对象的三要素五原则，有个鸟用），这么一排除，再把数据结构和算法设计一合并，就剩下程序设计、算法和操作系统。没错，这三项搞定，国内外IT公司通杀。 因此我的笔试和面试准备很简单，就是重温+突击程序设计、算法和操作系统。下面是我的笔试+面试准备内容： 程序设计： 1，把基础的数据结构的C语言实现在纸上写三遍以上，用我能想到的最精简最优化的方法 2，阅读CARM和TCPL，确保不会遗漏C语言的每个细节 3，重温之前自己做过的靠谱项目，并总结里面的关键难题和解决思路 4，重读Writing Solid Code、Elements of Programming、Practice of programming 5，阅读Science of Programming，做到可以证明自己的程序的正确性（前条件+后条件+不变式） 算法： 1，重读Algorithm Design Manual，重点阅读Dynamic Programming和Backtraverse 2，重读Programming Pearls和More Programming Pearls，并完成所有课后题 3，独立解决编程之美里面的题目（国内不少企业选题用的这本书） 4，完成Careercup里Amazon、Google和Microsoft这三个分类下面的前20页面试题 5，完成TopCoder的数十道D1L2~D2L1难度区间的算法题目 操作系统： 1，重读Modern Operating System，重温OS的核心概念 2，重读Computer Systems a Programmer’s Perspective的关键章节，回顾里面的关键点 从七月底开始一直到十一月，花了接近四个月，很多东西都是一边面试一边准备：面试-&gt;发现盲点-&gt;修复盲点。 此外列出一些面试笔试题的资源，此外感谢基友@codewarrior之前的推荐： 1，Crack over the code interview 很靠谱的笔试面试指导手册 2，CareerCup 集齐了大量的真实笔试面试题，去外企的一定得看 3，TopCoder 如果不是ACM，练这个就够，其实面试也不会问太难的算法，哪怕是google 4，编程之美 尽管题目有些过时，但依然很实用，三星题目适合一个人仔细想 此外也说下一些不靠谱的资源： 1，IT公司面试100题 这个恐怕是国内传的最多的IT面试题 题目本身还可以，但那个出题人本身代码功底一般，给出的答案包含大量错误和缺陷，导致参考价值骤降 2，程序员面试宝典 翔一样的书，各种错误概念的堆积，如果一个错误给我一块钱，我能从这本书搞成万元户。如果去正规公司拿这本书准备，包你被黑出翔。 4，简历 在MS时，老大曾让我帮忙招几个靠谱的实习生，因此我收到了几百封简历，过了一把HR的瘾。这里说说自己在看简历时发现的几点： 1，可读性。不要用Word或压缩包，用PDF。此外在邮件里面用纯文本加上自己的简介，简化对方阅读的操作。要记住HR一天看的简历海的去了，压缩包是HR最痛恨的格式，因为解压了就不知道扔哪去了，有时干脆就不看；Word有版本问题，10的docx到了07往往被黑出翔。还有就是对方有可能不在PC上读邮件，因此纯文本的简介非常有必要。 2，群发。不要给人群发的嫌疑，看清楚目标职位和目标公司，我发的工程院招聘贴，收到的几百封简历里面有十余封是投到微软亚洲研究院，有几个干脆写“敬爱的某领导”，尼玛这不找抽么。 3，设计。特别提一下设计，很多电工的简历就是翔，丑的一逼，对齐没有，字体拙计，要点不明。再放到几百份几千份简历里面，活该你被忽略。建议所有电工投简历前阅读《给大家看的设计书》，至少搞明白里面的C.R.A.P四原则。不要小看设计的威力，在简历内容接近的情况下，良好的设计会大大加分。 4，篇幅。控制在一页以内。倒不是说不能写两页，而是HR没时间看两页这么多。而且就我看过的几百封简历而言，凡是超过两页的没一个靠谱，有这么高的先验概率，HR才没工夫一个个筛，反正中国有的是人。 5，重点。一定要有重点，做到让HR通过简历在20秒内确定你靠不靠谱。可以用加黑字体进行视觉引导。 6，措辞。甭搞“渴望得到这份工作”、“期待在xxx的工作机会”这样的句式，除了显得你低端，其它毛用没有。 7，别字。千万不要出现错别字，别字简历一般直接干掉。一页的简历都能出问题，一般不会靠谱。 因为看了很多不靠谱的简历，我对简历重要性的理解要比其他人深刻很多。首先花了一周把原来两页半的纸缩到一页内，然后找UI朋友帮忙调整了版式、缩进和字体，并找UX朋友帮忙进行重点调整以进行视觉引导，然后在PC和手机上进行了简历可读性测试。从而获得了100%的简历通过率。 此外，优先走内部推荐，这样最有效率，所以结识各个公司的朋友是非常有必要的。 海投简历既没必要也没效率，有这个时间不如改改简历来的实在。 相关书目： 1，给大家看的设计书，让你的简历看起来不像一坨翔。 2，Google Resume，如何写出靠谱的简历，进行靠谱的求职。 5，笔试 如之前所说，IT公司的笔试相对单纯（程序设计、算法和操作系统），而且范围较窄，有不少题目被出了一遍又一遍。因此市面上存在大量面试/笔试宝典之类的书籍和题集。 准备国内的小公司，这些面试/笔试题集还靠的住，因为小公司往往不会在招人环节上下太大的成本，因此他们的试卷一般就是东拼西凑的网上题目；对于大型公司来说，这些题库或是宝典就显的不够用了，尤其是外企。 所以不要把希望放在运气或是临阵磨枪上。就我自己而言，笔试准备了一个多月，尽管这个时间并不算多，但由于自己平时一直在阅读CS的基础书籍，并做了大量的纸上代码练习，因此笔试通过率也达到了100%（实际上是由于我笔试的公司题目都略简单，据说EMC和网易游戏的笔试难度很高，但当时由于时间冲突没有去成，因此搞出了这个数据）。 多说无益，这里拿搜狗、腾讯、微软和雅虎这四家公司的笔试试卷为例，简单的介绍下IT公司的笔试题型和题目组成。 搜狗： 题型由十余道不定项选择题和三道算法题目组成，要求在两个小时完成。选择题难度一般，比较杂，也有一些原题；三道算法题目有点意思，至少网上是很难找到，需要一定的算法设计能力（主要是动态规划）才能给出解决。 搜狗的笔试试题按职位分的很细，从C++开发工程师到iOS开发工程师再到数据挖掘研究工程师十余个职位，每个职位的题目都有一套独立的试卷。但是研发的算法题是一样的，最后一道算法题很有意思，我花了一个多小时才想到利用组合数学里面的知识（多元一次方程非负解）给出设计方案，后来和面试官聊这道题时他们也挺吃惊，因为我的方案比他们的答案还要优化。 腾讯： 题型由二十道单项选择题、六道填空题和两道算法题组成，其中两道算法题是二选一。难度比较简单，题型很广，既有程序设计语言的细节也有概率统计的基本知识，甚至还有C语言的创始人是谁这样的搞笑问题，从选择题上能看得出腾讯在笔试题上还是下了点功夫的，但算法题就太简单了点，至少我认为考不出什么区分度。 腾讯的笔试试题也是按职位划分的，但就没有搜狗那么细了，研发类笔试题目是统一的，要求一个半小时完成，印象里自己四十分钟就搞定收工，很多人都提前交了试卷，因为确实很简单。 微软： 题型只有二十道不定项选择题，难度较难，要求在一小时四十分钟完成。难度较难，覆盖面非常广，从设计模式，算法分析，代码阅读到C++语言特性，甚至连冷门的函数式程序设计语言都有涉及。 微软的笔试题目BT之处在于其独特的积分机制：答对了加分，不答无分，答错了倒扣。这就使得很多ds答完试卷感觉自我良好但实际已经被倒扣出翔。以最后一道题为例，答对了加7分，答错倒扣13分，相当于一下子损失20分。所以微软的笔试题会做就得做对，不会做就别蒙，要不更惨。 此外，微软的笔试题是英文的，加上时间比较短，有些人题都读不完，有些ds连functional language是什么都不知道，自然败的很惨。 雅虎： 题型由十余道单项选择题，一道设计题目和六道算法题目组成，其中六道算法题目是六选二，要求在两个小时完成。难度尚可，主要考察编程能力和算法设计能力。由于时间充裕，尽管是六选二，为了炫技，我直接答了里面的五道题目。然而面试时发现面试官判卷子时并没有把多答的题目考虑在内，囧tz。 相对于微软，雅虎的题目覆盖面就窄了许多，没有一道题目跳出程序设计、算法和操作系统这个圈的，只要勤加准备，很容易通过。 雅虎的笔试题也是英文，因此英语作答较为合适，此外，由于算法题目简单，给出optimalsolution是必须的，比如说在logN的时间内算fibonacci number是必备的知识，能写binary search就不要写sequentialsearch等等。 从笔试题可以明显看出，国外的大型IT公司（比如雅虎，微软和谷歌等）并不在意你现在的skill set，而更看重你的potential，因此题目大多很基础，并具备相当的深度，以确保你对CS有深刻的理解并能够走的很远；而国内的IT公司（比如百度、搜狗和人人等）更看重你现在的skill set，因此会出现不少语言特性，OS操作之类的具体题目，以确保你能够以尽快的速度上手干活，至于能发展到啥程度他们就不care了。 因此，准备笔试题的时候要确定自己的目标公司：主攻国内公司的话，C++的语言特性、linux基本命令操作这些细节也得准备，因为会有大量此类题目；主攻国外公司的话，良好的英文阅读能力必不可少，此外优秀的代码理解和代码编写能力也不可或缺。 此外，不要在笔试题目里犯低级错误，不要抄袭（面试时经常会问到笔试题），保持书写的工整（尤其是代码题目和问答题目）。 考虑到几乎所有的公司都有编程题目，也就是在纸上写代码，这里推荐几本相关书籍： 1，Elements of programmingstyle2nd，写出良好风格的代码。纸上代码一般不长，但短短几行代码往往可以看出这个人的水准，风格很差的代码往往会被pass掉。 2，Algorithm design manual2nd，作为非ACM出身的码农，这本书比算导实用很多，课后题也很实在，对回溯，动态规划这些编程技巧讲的非常清楚。 3，C interfaces andimplementation，无论是面试还是笔试，一般都会用C写程序，这本书包含大量的工业级C代码，绝佳的参考和模仿素材。 最后推荐下Elements of programming和Structure and interpretation of computerprograms，这两本书难度很搞，需要大量的时间阅读，不适合临场阅读准备，但读过后，写出的代码绝逼会上两个层次，这里我就不多介绍了。 6，面试 之前有人PM我关于海投简历的问题。我个人不建议海投简历。因为对能力弱的人来说，海投简历只会让他信心更差，没有任何效果，有投简历的时间还不如精心准备少数几个好公司；而对能力强的人来说，海投简历之后会有大量的笔试和面试，笔试很耗体力，面试更很耗体力，不但需要打车或坐地铁在各个公司间穿梭，而且需要在面试时保持精神的高度集中，一般面下来都会精疲力尽，导致接下来的发挥不好。所以还是之前所说，优先内部推荐，然后再根据自己的情况和职业发展路线选择公司，选择职位，不用选太多，集中精力攻破领域内的TOP3即可。就我自己而言，求职期间，我一共投了12封简历，参加了12家公司的面试，一共面了35轮。说多不多，说少不少，因为自己投简历时也是本着互联网公司为主，小公司和企事业单位压根没有投，精准投放的好处在于可以集中精力准备同一类型的公司，从而达到不错的效果。 关于简历海投的问题就说到这里，接下来讲讲IT公司的面试。需要注意的是我这里聊的都是应届生面试，社会招聘面试可能会有所区别，但整体流程不会有太大差异。 尽管笔试题会有所差别，但IT公司面试的流程大同小异：标准的技术面试一般有45分钟到60分钟，大约分为三个阶段： 1，自我介绍（5~10分钟）： 这个环节的主要目的在于建立面试官和求职者之间的沟通，面试官已经扫过你的简历，但需要对你有进一步的了解，以便建立一个初步印象，并便于进行接下来的技术提问，所以这个环节最常见的问题无外乎“进行一下自我介绍”，有时会加上3分钟或是5分钟的时限，有时会询问“说说你最得意的项目/作品”之类的变体问题。 由于这个环节相对固定，因此准备起来相对容易，但即便如此，面试初期时我在自我介绍环节也犯过不少错误。这里以我的经历简单的总结下这个环节的要点： 1），言简意赅，突出亮点 面试初期时，我犯的一个很大的问题就是自我介绍废话太多，诸如“出生自xx省xx市”，“自我评价xxx”之类的屁话连篇。要知道技术面试不是相亲，这里的自我介绍不是相亲里面的查户口本，而是要了解你这个人靠不靠谱，牛逼不牛逼。如何在3分钟内让别人觉得你牛逼呢？很简单，说且仅说你最牛逼的事迹，让对方留下深刻印象。就技术面试而言，牛逼的事迹包含三方面：做过的项目，读过的书，认识的人。 如果实在想不出来有啥牛逼事迹，那就比较难办。说实话，换做你是面试官，招一个履历毫无亮点的人进来有何用？ 2），紧贴简历 面试官了解你的另外一个途径就是简历，然而短短一两页的简历很难说明白你简历项目中的亮点和难点。就算你不提及，面试官也会在简历中挑他感兴趣的点进行提问，因此自我介绍的内容应该是简历的补充。这样既能留给面试官不错的印象，也能有效节省时间，留出更多的时间进行技术提问环节和问答环节。 此外，千万不要搞出自相矛盾，比如说简历讲的做了A你在自我介绍中又说是B，这就不是拙计的问题了。 3），了解公司需求 不要试图用一套自我介绍来搞定所有公司，除非你的简历只有一句话（”Exhausted graphic programming”或是”I wrote python”等）。不同的公司有不同的需求，在Google面前大谈.net技术显然不是什么好的选择（我在google一面中就做过这种挫事）。面试之前要进行详细的调研，了解公司和职位的需求，然后根据他们的需求定制自己的自我介绍和简历，效果会更好。 2，技术提问（35~45分钟）： 通过自我介绍环节，面试官会对你有一个大概的评估，接下来会通过一系列深入的问题考察你的项目经历和技术能力。所以自我介绍环节不要吹牛逼，技术面试是很实在的东西，你有几斤几两问几下就出来，根本忽悠不过去。 按照MS的分类，技术面试问题分为三类： 1，Behavior questions：此类问题针对面试者的过往经历，一方面考察面试者的表达能力和实际经验，一方面也可以排除掉一堆在简历上吹牛逼的真ds： “说说你最牛逼的项目？” 2，Hypothetical questions：此类问题会假设出一些场景，让面试者进行作答，主要考察面试者的应变能力和实际经验： “给你三天，你会如何把xx项目做得很牛逼？” 3，Probing questions：如果前两类问题答的不错，面试官往往会追加一些问题，以探测面试者能够走多远，此类问题的出现也是一个标志，面试官对你之前的表现感觉还不错： “你会如何改进你做过的最牛逼的项目？” 就具体技术问题而言，考察题目视你的应聘职位和你的过往经历而定，开发岗会侧重代码编写和系统设计，测试岗会更注重测试用例的编写等细节，产品岗要对线框图，交互设计有了解。不过算法设计和代码编写这两块是肯定有的，毕竟这是程序员的看家功夫，这个搞不定就没有然后了。 算法设计这块我就不多说了，不搞ACM的码农没啥发言权。代码编写的话这里多说两句：和平时的开发不同，面试时的代码往往是在纸上搞的，而非IDE。很多代码写的还不错的选手往往会在纸上代码这个环节被虐的翔尿齐飞，限于篇幅原因我就不多介绍纸上代码的技巧了，还是那句话，多练习。我自己把SoftwareTools、Elements of programming和C interface andimplementation中的代码在纸上写过几遍，又把常见的面试题目练习了三遍，因此纸上代码环节从来没出过问题。 3，问答环节（5~10分钟）： 如果前两个环节进展顺利，就会进入最后的问答环节。这个环节面试官一般会让面试者提几个感兴趣的问题，以增进相互的了解。 相对于前两个环节，这个环节会轻松很多。不过依然要注意，关于面试表现的问题最好别问，因为问也问不出来什么，至于待遇，那是HR的事情，技术面试官也无能为力。 最后根据自己的面试经历说说几个细节的问题 态度：记住你是去求职，证明自己的能力达到职位需求是你的首要任务。没有必要和面试官抬杠，把面试官搞不爽对你一点好处都没有。我在面试搜狗时就出过这问题（直接表示对面试官的问题的不屑），直接一面被砍掉。 着装：尽管IT公司大多不需要西装革履，但也别太拖沓，穿整齐些，至少给人很精神的感觉。我面试腾讯时直接搞了一件套头衫+迷彩裤+机车帽，结果是面试官从头到尾就没正眼看过我，直接一面被砍掉。 交流：面试是一个交流的过程，不明白的一定要主动询问，面试的大忌就是面试官给了一个问题，你一声不吭的搞了一个小时，最后发现搞的不是面试官问的问题，这时就算你很牛逼，面试结果往往也是悲剧。 7，国企 国内的IT公司一共去了6家，拿到6个offer，面试19场。 百度（2轮面试+1轮终面） 百度的应届生面试分为3轮，2轮技术面和1轮终面，3轮面试连在一起进行，如果搞到第1轮或第2轮就叫你回去，基本上不是悲剧就是备胎。如果进了终面，只要不出岔子，一般问题不大，因为百度每年招的人非常多，印象里有1500人之多。 可能是招的人特别多从而导致面试官人数不够，百度的面试在所有大公司里面几乎是最随意的，面试官往往都没有经过系统的面试培训，出的题目也只是从网上东拼西凑，比如像C++的虚函数的实现机制此类SB题目层出不穷。而且有些面试官缺乏对面试者最基本的尊重，我有几个同学在百度面试时差点被面哭。 就我个人而言，我先后参加了百度的实习生面试和正式员工面试。正式员工面试给我感觉相当不错，流程很规范，面试官很nice，问的问题也说的过去；然而实习生面试那两个人就是翔，不但问的问题很二，而且不给我任何交流的空间，同时在面试过程中表现出一副非常不屑的神情，令人极度不爽。 此外，百度的员工（包括面试官）给我一种工作过度的感觉，说惊悚些就是印堂发黑。结合艳红哥提到的狼性精神，我这号酱油男说啥也不敢去。 搜狗（2轮面试） 搜狗的应届生面试分为4轮，2轮技术+1轮HR+一轮Manager，4轮面试是分开的，所以会比较麻烦，毕竟来回跑来跑去的很费时费力。 我的搜狗面试经历比较诙谐，尽管面了2轮，但2轮都是一面，第一个一面是朋友帮忙推荐过去的面试，第二个一面是参加搜狗笔试获得的面试机会，从这里多少能看出搜狗招人是有点混乱的。 第一个一面非常囧，当时面试官问我C++，我表示很少用，接下来问了若干智力题，由于被问的有些拙计，于是反问“这种智力题有什么考察度，会做的人一下子做出来，不会做的一天也搞不定”。估计这句话把面试官搞毛了，接下来的气氛变的很紧张，后来面试官反问我“那你觉得应该怎么招人”，我回答“你们应该学学微软”。然后就没有然后了，囧tz。 第二个一面感觉还成，因为我笔试的题目答得比较出彩。接下来是一个strcpy的纸上代码和一个简单的OS生产者消费者问题，答得还算顺利，可惜依然没有然后，我怀疑可能是没有Hire Count了。 搜狗面试给我一个很大的教训，就是别装逼，求职就是求职，别和面试官抬杠。在接下来的面试中，我收敛了很多。 创新工场（2轮面试+4轮终面） 创新工场本身是一个孵化公司，它的招聘流程是这样的：工场进行笔试和面试初选，然后由工场下面的子公司进行复选，由于子公司众多，因此工场有一个双选会，每个通过初选的求职者可以选择3家工场的子公司，在这个双选会上开复哥很是鼓吹创业，不过效果似乎不太理想 :-D 工场的初选面试有两轮，然后是3个子公司的复选面试。和其它公司不一样，工场的面试时间非常短，只有25分钟：一个自我介绍，两个无需写代码的题目。有点拼人品，因为这么短的时间很难考察全面。复选面试大多是电面，比较简单，算法题目说下思路就可以。顺便推荐下友盟，感觉这些子公司里面这家的发展潜力最大。 腾讯（1轮面试） 腾讯的应届生面试的组成我不太清楚，因为1轮就GG了。 腾讯的面试也让人很火大，面试官直接拿一个laptop在那里给你放ppt，一个slide一个题目，答完下一个slide，结果是我说的口干舌燥面试官还没说两句话。题目五花八门，从简历到智力题再到为人处事，印象里答了不下七八道题目，累的一逼还没通过，尼玛。 不过腾讯的面试中见到很多PLMM，目测有很多非技术岗。 人人（2轮面试+2轮终面） 人人的应届生面试一般是2轮面试+1轮终面，由于我的笔试和面试发挥不错，因此又得到了一个加面的机会，拿到了人人special offer，待遇非常给力。 人人的一面面试官非常nice，我当时迟到了30分钟，由于没吃饭因此直接蹭了几个面包，一边吃一边回答问题一边写代码。由于一面主要考察纸上代码，这个是我的强项，因此很轻松的通过了。二面相对杂一些，数据结构，算法，设计模式，多线程等都有涉及，不过问的都不深，也比较容易。 终面第一面由自我介绍+读过的书+写一段代码组成，正好刚刚读过Sicence ofprogramming，于是就海侃了一顿程序正确性证明的东西，并用这个证明了下自己的代码的正确性，目测效果还不错。 终面第二面是一个大manager面试，这一轮主要是自己的职业发展路线等其它非技术问题，聊的也比较顺利，然后他直接告诉我我拿到了special offer。 人民搜索（2轮面试+1轮终面） 人民搜索的应届生面试由1轮算法面+1轮设计面+1轮终面组成，每一轮面试都是45分钟，时间控制很严。 和其它公司的面试不同，人搜的算法面试没有自我介绍环节，直接就是搞算法题目，至少要做两道（难度一般，肯定会有一道动态规划），并在纸上写出完整的代码。由于缺乏沟通，这轮面试略感生硬，不过还是比较顺利的通过了。 设计面试多了一些沟通环节，接下来大部分时间会讨论一个系统的设计，你需要给出这个系统的架构，接下来面试官会不断的追问如何改进该系统以应对大用户量大数据量等极端情况。我这方面的知识不多，只会很土鳖的hash+cache，磕磕绊绊的把这轮过去了。 终面面试官是一个前google工程师，正巧当时我在google面了好几轮，比较了解google面试的套路，因此很顺利的就通过了。 总之，人民搜索的待遇比较给力，而且能搞定户口，如果想在北京长待而且视户口很重，那么人搜值得一试。 8，外企 国外的IT公司一共去了4家，拿到3个offer，面试16场。 微软（2轮面试+1轮终面） 微软从去年开始大规模扩招，印象里以前应届生招几十人，现在一个STC（互联网工程院）就能招二百余人，因此面试难度也有所下降，面试轮数由以前的5轮左右下降到现在的3轮左右。 这里多提一句，很多人把微软和MSRA（微软亚洲研究院）划等号，甚至有人认为进了微软就等于进了MSRA，其实微软有很多部门，包括STC、STB、MOD等部门，MSRA只是其中一个研究性质很浓的部门。不过MSRA要求极高，和其它部门不同，一般MSRA的FTE只招博士，很少招硕士，招聘需要进行七轮甚至以上的严格面试，难度丝毫不亚于谷歌。而MSRA的实习生则容易很多，名校学生一般有内部推荐就可以搞定。 我之前在微软进行过实习，因此直接参加了实习生转正面试，三轮面试分别由SDET，SDE和一名高级部门经理进行面试，面试的流程可以参考我之前提到的常规面试流程。与国内IT公司不同，微软不会问语言细节或是OS细节之类的人品问题（就是那种上网搜一下就明白的题目，C++的虚函数实现机制是此类非常典型的人品题），而会集中在算法设计和程序设计上，其中应届生面试又以纸上代码最为严格，即使到了终面依然会有纸上代码编写环节，尽管不会考察特别复杂的算法，但对细节要求的非常严格。好在我之前有微软几位SDE的指导，纸上代码功夫还是不错的，并且实习期间获得了不错的review，因此比较顺利的通过了微软实习转正面试。 微策略（2轮面试） 微策略是一家进入中国没多久的外企，规模不大，工作内容主要是大数据分析+数据可视化，面试一般由四轮到六轮面试组成。我比较悲催的直接挂在第二轮面试。 微策略是我面试的外企中唯一全程使用英语面试的公司，面试官给人的感觉是很smart，但不nice，具体原因我后面说。 第一轮面试主要问了些面向对象相关的内容，接下来是一些智力题目，我有一道题目（高楼扔鸡蛋）没有说清楚，尽管答案是正确的，但我的推导思路比较繁琐，因此浪费了大量的时间和面试官进行沟通。事后回想下面试官还是很nice的，主要还是自己平时想问题浅尝辄止，才会败在这道题上。 第二轮面试就让我感到不爽了，我在自我介绍时直接被面试官打断，以至于自己的亮点经历说都说不出来，而且在后续的编程环节中，面试官拒绝和我进行交流，我写完了题目他又说这个和他要求的不太一样，当时我心里就开始暗骂wtf了。估计是前一轮被评为weak hire以至于这一轮的面试就是走走形式吧。 雅虎（3轮面试+1轮终面） 雅虎的面试分为3轮技术面和1轮终面，在同一天完成。尽管雅虎公司一直给我一种摇摇欲坠的感觉（经常有传言雅虎可能会被收购），但雅虎公司的员工给我感觉都很nice且很smart，而且比微软的员工要有活力许多。 三轮技术面试有两轮是典型的技术面，自我介绍+技术提问，由于我在简历上提到“阅读了120本以上的计算机经典书籍”，因此被问到了“看过最经典的计算机书”这样的问题，我拿Brian Kernighan和Rob Pike的The practice ofprogramming吹了一阵，算法题目相对微软要难一些，除了动态规划，也涉及到了后缀数组等不太常见的数据结构，还好之前有所准备，所以回答的还不错。 终面的面试官是一名移动部门的老大，问了一些数据结构设计和职业规划的问题，并用英文进行了一小段交流，由于这些问题准备的很充分，因此跟他聊的比较high，终面也很顺利的通过了。 Google（7轮面试） Google的面试轮数不定，如果表现良好，4轮面试就可以拿到offer，但如果有某轮面试表现一般，可能会进行加面来进行确认面试者是否合格，拿我自己来说，进行了7轮面试（据说有进行到10轮以上的，不过无法确认可信性）。Google是典型的工程师文化工程师面试，没有终面这个说法，每个面试官都有一票否决权，加上每个面试官考察的点都不一样，因此Google面试是我经历过的难度最高的面试。 其实Google的面试我本来没抱多大希望，因为Google一直给我可望不可及的感觉，因此面试时也很放松，这种“自暴自弃”的心态反而让我发挥的不错，一步一步走到最后，并拿到offer。 Google的面试每一轮大约45分钟，时间卡的比较严格。面试题目肯定会包含算法和程序设计（一般体现为纸上代码），同时包含其它各种各样的问题，我经历了策略题（设计一种策略从而在某个游戏中达到优胜）、数据结构设计、系统设计、白盒/黑盒测试、项目介绍等五花八门的题目，题目的类型视面试官的类型而定：学术型的面试官（比如说名校PHD）问的题目偏重算法，工程型的面试官（大多是社招的Googler）问的题目偏重项目经历。面试题目并不像网上传说的那么困难，但是面试官会抛出很多Probing question，让你给出一个optimalsolution，这着实让我拙计了几次，不过即便一时间想不到最优解也不要紧，一边保持和面试官的交流一边试探各种可能的思路，这里再次推荐下Polya的Howto solve it。 由于面试轮数很多，因此这里就不依次说每轮面试的细节，可以参考下面的Google面试经历链接。 《面试体验：Google 篇》 9，总结 笔试难度：微策略&gt;人搜&gt;人人&gt;雅虎&gt;搜狗&gt;创新工场&gt;腾讯 面试难度：Google&gt;雅虎&gt;人搜&gt;微策略&gt;微软&gt;人人&gt;百度&gt;腾讯=搜狗=创新工场 待遇：Google&gt;人人&gt;人搜&gt;雅虎&gt;微软&gt;百度&gt;创新工场旗下子公司 毫不犹豫的选择了Google，尽管我自己是.Net流，天天折腾VS和C#，linux和unix啥的都没碰过，但就前景来看，不得不承认Google比微软强太多了。 老实说我自己进Google感觉像做梦，毕竟不是搞ACM的，大学成绩一般，什么奖学金都没拿过。 但回想一下，这也不全是靠运气：从07年（那时我大三，一行代码没写过）挂科开始，决心开始搞计算机这行，编写自己的第一行靠谱代码，独立完成第一个编程作业，阅读书籍，不懂的就来D版询问各路大神（这里谢过FloridDong，UGLee等大神），然后一边实习一边读书学习，花了半年考研考到帝都，在考研结束的那段时间（四个月假期）精读了数据结构，计算机组成等基础经典书籍，补习自己的基础。到帝都之后，在一场即兴技术口译之后，获得去微软实习的机会，然后在实习中学习编译器知识，创作了自己的编程语言和编译器，加入朋友的创业团队并合作完成了AppStore TOP1的应用，离开团队独立搞定Windows Phone7上最火的拨号应用、阅读应用和AV应用并在移动互联网中赚到自己的第一桶金，通宵一周完成毕业小论文发表并推荐到核心期刊，为了求职写了三本纸上代码，阅读theScience of programming学会如何证明自己代码的正确性，100%的简历通过率+100%的笔试通过率，最后进入Google。","tags":[{"name":"面试","slug":"面试","permalink":"http://ichenwin.github.io/tags/面试/"}]},{"title":"关于健身","date":"2014-11-27T19:03:25.000Z","path":"2014/11/27/关于健身/","text":"对于女生，如果在家或是在寝室想要健身，以下是高科教练给的建议。我总结下，大意是： 女性在进行同样项目的运动过程中损伤几率远高于男性 你维持良好体型的关键:较低的脂肪比例与较高的肌肉含量 所以女子训练应该注重力量训练 首先练习肢力量和躯干稳定性，能避免关节损伤 重点来了： 训练动作最好先练习双脚脚掌站立平衡稳定，徒手深蹲，侧蹲，同时加强躯干稳定性，增加平板支撑，侧撑等动作 训练方式尽量选取循环训练，4个动作一个循环，做完一个动作马上进行下一个动作练习，直到完成一个循环，3分钟后再进行下一个循环，一共执行3-4个大循环。这种训练方式可以大幅度提高新陈代谢速度，促进脂肪燃烧，肌肉合成。 训练强度每3周调整一次。 训练频率隔天1次，一般9次训练之后就能看到身体发生明显的变化。 回答原文：女孩子平时在家里有哪些健身锻炼的好方法？那问题又来了，怎样的深蹲是标准的呢？答案在这儿：如何完成标准的深蹲？女生减肥请看这里：怎么减肥 至于男生，找到了像我这种瘦子适用的健身计划：增重计划五部分：原因→饮食计划→训练计划→休息恢复→心理1、消瘦的原因遗传 or 生活习惯 ？如果你从小在家吃好喝好也没胖过，家人也偏瘦，那主要就是基因问题了。 2、饮食计划 饮食比训练更重要 当你摄入的热量大于你代谢的热量时，你的体重就会增加 蛋白质、碳水化合物、脂肪和水。对于需要增重的人来说，更重要的是碳水化合物，足够的碳水化合物才能给你提供足够的热量去增重,所以要尽量多吃饭。脂肪可以随意些，不用严格控制，但也别比前两样还多；比例大概是：蛋白质30~40%，碳水50~60%，脂肪10~20%，水多喝些，一天八杯。 早餐必须有足够蛋白质和碳水。睡醒一大杯水，然后煮早餐吃几个肉包+自磨豆浆（含花生、核桃、芝麻等）+三个鸡蛋（只吃一个蛋黄）。（答主真TM能吃，Orz） 午餐尽量多吃，但别吃撑。两碗米饭+一大块鸡扒+一份常规炒菜+一份素菜+一碗汤 上午、下午加餐早上十点和下午两三点左右吃,有鸡蛋、土豆、圣女果、干果等具体见他的另一回答：上班族如何能「少食多餐」？ 晚餐和午餐几乎一样，鸡扒换鱼排，炒菜换点口味，一般5点半去吃，然后回公司加班到7点，出发去健身，到健身房也消化的差不多了。 夜宵健身完回到家，9点左右了，会先吃一根香蕉和一份蛋白粉，然后自己下碗饺子吃。 每天中午补一片善存，然后下午一粒维C泡腾片补充维C，注意维C的量每天要固定，要么一直多，要么一直少，不要时多时少，抵抗力容易下降。 鸡蛋主要是蛋黄胆固醇高，一天两个以内是OK的，蛋白就主要是蛋白质，很健康。 3、训练计划 对健身来说，可以将需要训练的肌肉分为大肌群和小肌群两个部分。其中大肌群有：胸、肩、背、腿小肌群有：手臂、小腿、腰腹要变壮优先把大肌群练起来。先把胸练大了，身板马上变厚，把肩练起来了，人马上变宽。背和腿长远来说更重要，但较难入门；而胸肌是最容易入门的，所以前期可以在优先训练胸肩背腿的同时，让胸肌更优先一些。 而一身肌肉，不可能一天全套练完，需要分几天时间练完。所以我一般一周去四天健身房，以胸肩背腿为主，附带手臂小腿腰腹。周一：肩+小腿周三：背+肱二头肌+腰周五：胸+肱三头肌周日：大腿+腹肌 训练方式主要是，大重量，低组数，复合动作，自由重量为主。 大重量：充分热身后，做6~8RM的强度，组间休息90秒（这个RM意思是力竭数，例如8RM意味着，这个重量如果你用尽抓奶的力气，一组也只能做8个就力竭了，如果不休息就再也做不起第9下了，叫8RM；如果你做了8下，明明还有余力做第9下，却停下来不做，这不叫8RM，叫训练不到位） 低组数：一般大肌群使用4个动作，每个动作4组；小肌群使用3个动作，每个动作3组 复合动作：像卧推、深蹲、引体向上、推举、硬拉这些多关节，一次要用到多块不同肌肉的动作，就叫复合动作，瘦子入门要多练；相对应的，像集中弯举这些只会用到肱二头肌偏外侧这么一小块肌肉的动作，叫孤立动作，前期不需要做太多。 自由重量：用杠铃、哑铃训练叫自由重量，前期应该尽可能使用自由重量，这样能锻炼你控制重量的能力和肌肉协调能力，也能充分刺激更大区域的肌纤维。如果在机械上做阻力训练，刺激到的区域很局限，你也学不会控制肌肉，效果较差，这个阶段使用机械的动作不应该超过20%。有人说机械更安全，适合新手学习动作标准姿势——好吧你也可以前两周用机械感受，第三周开始就该换自由了，我是一开始就使用自由重量，姿势可以看视频学，可以问身边的小伙伴，怕危险可以从很轻的重量开始练。 下面给出具体的训练计划：每块肌肉的第一个动作，必须至少用15~20RM的小重量热身两组，并且适当拉伸肌肉，才能开始训练。动作的幅度一定要全，不能只推一半距离就算完成了，这样不会有好效果。计划列表内，黑体加粗的是该部位的主要动作，每隔6周，将“杠铃”和“哑铃”轮流替换。 动作名称 组数，每组次数（力竭） 周一：肩、小腿坐姿杠铃推举 4组，分别10、8、6、3RM站姿借力推举 4组，8RM直立划船 4组，10RM哑铃侧平举 3组，12RM（递减组，例如先用12磅哑铃做到力竭，马上换8磅的再做到力竭）俯身哑铃侧平举 3组，12RM（递减组）站姿提踵 4组，12RM坐姿提踵 4组，12RM 周三：背、肱二头肌、腰宽握引体向上 分多组，一共做50个（一个都做不起来就先用宽握高位下拉代替，4组，10RM）俯身划船 4组，10RMT杠划船 4组，10RM坐姿划船 4组，12RM杠铃弯举 3组，12RM哑铃交替弯举 3组，12RM硬拉 充分热身，3组，分别8、6、3RM罗马椅挺身 3组，12RM 周五：胸、肱三头肌杠铃卧推 4组，分别10、8、6、3RM上斜杠铃卧推 4组，10RM屈臂撑 4组做至力竭仰卧飞鸟 4组，12RM坐姿颈后哑铃臂屈伸 3组，10RM仰卧臂屈伸 3组，10RM，做完一组后马上继续做窄握推举至力竭背后屈臂撑 3组，10RM 周日：大腿、腹部自由深蹲 6组，分别12、10、8、6、6、3RM腿举 6组，8RM哈克深蹲 4组，10RM腿弯举 4组，10RM卷腹 4组25次反向卷腹 4组25次这儿是回答原文：很瘦的人该制定怎样的健身计划？关于锻炼胸肌：如何练胸肌？","tags":[{"name":"健身","slug":"健身","permalink":"http://ichenwin.github.io/tags/健身/"}]},{"title":"《遇见未知的自己》","date":"2014-11-26T16:40:09.000Z","path":"2014/11/26/《遇见未知的自己》/","text":"潜意识与意识占比关系图：人脑子里闪过的念头大概有95%是潜意识想法，自己几乎完全无法察觉。所以你的绝大多是举动都是都不是你有意识的行为。我们应该尽可能多的去发现自己的潜意识，去将那5%扩大，从而让自己的更多意识说我们支配，让行动更有目的性，而不再任由潜意识摆布。 本书的思维导图，由网友”藏椿寒南昌”制作： p{text-indent:2em}","tags":[{"name":"心理学","slug":"心理学","permalink":"http://ichenwin.github.io/tags/心理学/"}]},{"title":"《围城》摘录","date":"2014-11-26T13:51:05.000Z","path":"2014/11/26/《围城》摘录/","text":"Page 4 忠厚老实人的恶毒，像是饭里的沙砾或者出骨鱼片里未净的刺，会给人一种不期待的伤痛。 有人叫她“熟肉铺子”(characuterie),因为只有熟肉食店会把那些许多颜色暖热的肉陈列；又有人叫她“真理”，因为据说“真理是赤裸裸的“。鲍小姐并未一丝不挂，所以他们修正为”局部的真理“。 Page 9 这一张文凭，仿佛有亚当、夏娃下身那片树叶的功用，可以遮羞包丑；小小一方纸能把一个人的空疏、寡陋、愚笨都掩盖起来。自己没有文凭，好像精神上赤条条的，没有包裹。 Page 12 长睫毛下一双欲眠似醉、含笑、带梦的大眼睛，圆满的上嘴唇好像鼓着在跟爱人使性子。 Page 34 处女的耳朵已经当众丧失贞操 Page 44 也许因为战事中死人太多了，枉死者没消磨掉的生命力都迸作春天的生意。 Page 79 这封信要寄给你了，还想写几句话。可是你看纸上全写满了，只留这一小方，刚挤得进我心里的那一句话，它还怕羞不敢见你的面呢。哎哟，纸—— Page 141 真是无微不至，汗毛孔的折叠里都给她温存到。 Page 143 外面雨停了，头脑里还在刮风下雨，一片声音。 睡眠闷棍似的忽然一下子打他入黑暗底，滤清了梦，纯粹、完整的睡眠。 一觉醒来，天气若无其事的晴朗，只是黄泥地表示夜来有雨，面黏心硬，像夏天热得半溶的太妃糖，走路容易滑倒。 Page 144 也许女孩子第一次有男朋友的心境也像白水冲了红酒，说不上爱情，只是一种温淡的兴奋。 Page 174 对于丑人，细看是一种残忍——除非他是坏人，你要惩罚他。 Page 214 竹叶所剩无几，而冷风偶然一阵，依旧为了吹几片小叶子使那么大的傻劲。 Page 216 那张呈文牢牢地贴在他意识里，像张粘苍蝇的胶纸。 Page 246 两个人在一起，人家就要造谣言，正如两根树枝相接近，蜘蛛就要挂网。 Page 302 物价像吹断了线的风筝，又像得道成仙，平地飞升。 p{text-indent:2em}","tags":[{"name":"文学","slug":"文学","permalink":"http://ichenwin.github.io/tags/文学/"}]},{"title":"《拖延心理学》序言","date":"2014-11-22T21:40:14.000Z","path":"2014/11/22/《拖延心理学》序言/","text":"写书的人往往被认为对他们的写作倾向有着非常深入的了解。确实, 我们对拖延心理的了解可以说是彻头彻尾的：我们两个都知道对方的那 些丑事，我们都经历过许多通宵开夜车的日子，也曾为写博士论文而挣 扎了多年，经常要缴纳税收滞纳金，并常常为自己的拖延而编造种种故 事情节（最为极端的例子是说自己家里死了人）。 除了我们两个人对此的个人亲身经验之外，我们也有多年与拖延心 理打交道的职业经历。当我们还是加利福尼亚大学伯克利分校的咨询中 心成员的时候，我们从1979年开始就为学生拖延者创设了据我们所知的 第一个团体治疗课程。在我们的拖延者团体中，我们看到一些拖延的模 式和倾向一再地呈现出来。虽然每个人的情况不同，但是其中还是有很 多引人注目的共性。举个例子来说，我们原计划在周一上午九点开始我 们一周的团体治疗课程，结果我们发现这根本不现实一在十点之前没 有一个人出现在现场！ 当我们向公众开设拖延工作坊的时候，我们再次遭遇到了这个拖延 怪兽。我们差点提前一周取消我们的第一个工作坊，因为在预订的时间 内没有几个人报名。结果，几乎2/3的人是在截止时间的最后一分钟报 了名，我们不得不搬到一个更大的房间里才能容纳下这么多的人。 30年来，我们在心理治疗和心理分析的私人诊所内也处理了很多个 案，很多人因为常年拖延而积重难返，这让我们有机会在更深的层次上 探索这个问题。我们感到幸运的是，患者们都勇于向我们敞开心扉，这使我们的研究工作从中受益良多。所有这些经验都再次坚定了我们的想法：拖延从根本上来说并不是 一个时间管理方面的问题，也不是一个道德问题，而是一个复杂的心理问题。根本而言，拖延的问题是一个人跟自身如何相处的问题，它反映 的是一个人在自尊上的问题。在我们的第一本书里，我们将它看做是一 个人自我价值感方面的问题。我们强调，自我价值感是以一种自我接受 的能力为基础的，其中包括接受我们的生理状况，接受我们的历史，接 受我们的环境，以及接受我们作为人的诸多局限性。 那么，为什么在25年之后我们决定修订这本书呢？我们想将拖延问 题放在当今文化的背景下加以考察，并在对拖延的原有认知上增补一些 新的视角。除了对这个问题更深人的心理学认识之外，我们还有来自其 他领域的一些资讯，比如神经科学和行为经济学，这些都有助于更好地 理解拖延问题。 25年前，对拖延的研究几乎是空白，但是现在已经有很多研究找到 了拖延形成的原因。2007年，卡尔加里大学(Univeraity of Calgary)的心 理学家皮尔斯•斯蒂尔(Piere Steel)发表了一篇评论，对将近800项拖 延研究成果进行了总结，其中包括我们在1983年出版的书，在他的评论 中这本书是最早被提到的研究成果之一。斯蒂尔最终找出了四个拖延最 可能的成因——对成功信心不足，讨厌被人委派任务，注意力分散和易 冲动，目标和酬劳太过遥远。我们很髙兴地看到这些研究和发现有力地 支持了我们的临床观察和总结，但是我们同时也认为还有很多其他东西 被这一类研究所忽视了。 自从本书第一版面世以来，这个世界已经发生了巨大的变化。在20 世纪80年代早期，大众根本无缘接触到互联网，那时候个人电脑也没有 普及。我们写作的时候是用铅笔写在本子上，然后将我们的手稿在IBM 的电动打字机上打印出来，我们俩人还要见面交换各自写的章节。为了 将我们的稿子隔天就交到出版商那里，我们经常不得不在下午六点之前 冲到联邦快递那里(如果我们错过了这个时间，我们还有一个选择就是 在八点乏前直接送到机场）。如今，电脑已经成了我们的纸和笔，同时也 成了我们的图书馆和邮件递送者。 在那个时候，没有黑莓(国外一种以收发电子邮件为特色的手机）， 没有PDA (掌上电脑），没有手机，更没有苹果手机(iPhone)。技术进步现在可以让我们每周工作7天，每天工作24小时，但是它也会引诱我 们每周7天、每天24小时地拖延着时间！不管你身处何时何地，也不管你是在工作还是在家里，我们都可以在网络冲浪中数小时地迷失自 己一阅读新闻，不停地搜索，摆弄博客，观看比赛，沉迷于虚拟的度 假和色情之中。在网络上总有适合你的东西。 事实上，网络越来越成了人们不愿意做事的罪魁祸首，这种趋势正 在不断地蔓延。如今，信息已经是铺天盖地、无所不在。过多的信息让 我们无所适从。太多的信息，太多的决定，太多的选择一信息的泛滥 让我们很多人陷入了拖延的泥沼之中。 在我们写书的今天，我们看到拖延比我们曾经设想的要更为复 杂一它不仅仅是个人心理、行为和情绪上的问题，它还涉及了社会、 文化及技术走向，生物和神经取向，以及全体人种的去向。因此，我们 将以更为慎重的态度来对待拖延的全部复杂性。 在写作这本书的时候，就像在25年前一样，我们相信，要让拖延之 手从你的生活中松开，既需要理解其运作原理，还需要找到应对措施， 采取相应的行动。你或许意识到了拖延是怎样耽误了你，但是我们觉得， 你或许并不了解拖延为你带来了怎样的潜在好处，所以，直到你看清楚 拖延是如何服务于你的之前，就像做其他事情一样，你还是会一再推迟 实践我们为你介绍的应对技巧。如果你没有理解自己为什么要拖延，所 有这些实用的技巧对你都不会有什么帮助。同样地，在你看穿了自己的 老底，完全地理解了自己拖延成因的情况下，如果你不付诸行动，你依 然不会有所进步。(阅读应对拖延的技巧或许是很有趣的一件事，但是阅 读不能代替行动。）所以，找到怎样采取行动的好办法是至关重要的。 在这本书的第一部分中，我们对产生拖延的形形色色的根源进行了 追溯；在第二部分中，我们给出了一些帮助你采取行动的建议。我们的 目标并不是消除拖延。很多时候对一些事情弃之不理反而对你最为有利； 相反，我们希望这本书能够让你更加接受自己，由你自己来掌握取舍和 得失。我们希望我们的读者对自己的人性抱着宽容乐观的态度，接受自 己的优点和弱点，能够与自己像老朋友一样和谐相处，通过这样的心态 来减缓拖延的惯性。我们并不建议你放弃雄心壮志和对卓越的追求，也 不是劝说你逃避全新的挑战。但是在我们将梦想付诸行动的时候，伴随 着内心冲突而来的，像恐惧、羞耻、担忧以及自我憎恶这样的情绪都是我们应该摒弃的。 我们不再像以往那样拖延。虽然莱诺拉每年还是要申请传真分机, 但是这不过是一件计划中的事情，不是什么心理恐慌的匆忙之举。虽然 简花了五个月的时间才将她的掌上电脑拿出包装盒，但是她现在在面对 大部分事务的时候都做到了及早处理。还有，虽然我们的第一本书的完 成比出版商给我们的最后期限超出了两年时间，但是这一次我们只需要 四周的延缓时间！我们能够证明改变是可能的，虽然我们也知道这并不 合易。 在这本书中，我们希望陪伴你面对拖延的挑战，学会接受，学会行 动，让自己的心理更为成熟。我们曾经就是这样陪伴着很多人穿越了他 们的拖延心理。出于保密的考虑，我们将所有人的姓名以及一些相关信 息都做了改头换面；我们在书中所描述到的拖延者往往是我们所了解的 几个人的一个综合体。我们希望，你在分享他们故事的同时，能够更好 地理解你自己的处境。正是在对你自己生活处境的审视中，你才能发现 你的拖延存在的真实背景。我们相信这一点是相当关键的，因为，当我 们按照自己真实的样子而不是按照自己希望的样子来接受自己的时候， 我们才能以最有利于我们的方式来采取行动，而不是生活在拖延的无边 阴影之下。 p{text-indent:2em}","tags":[{"name":"心理学","slug":"心理学","permalink":"http://ichenwin.github.io/tags/心理学/"}]},{"title":"Hello World","date":"2014-05-27T10:04:08.000Z","path":"2014/05/27/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 问题收录 提交的时候遇到Deployer not found: git解决办法：运行npm install hexo-deployer-git --save","tags":[{"name":"博客 CSS","slug":"博客-CSS","permalink":"http://ichenwin.github.io/tags/博客-CSS/"}]},{"title":"CentOS 6.5设置","date":"2014-04-12T05:10:00.000Z","path":"2014/04/12/CentOS 6.5设置 /","text":"编辑sudoers文件,先备份/etc/sudoers，之后使用su切换到root下，在sudoers中，找到 root ALL=(ALL) ALL后，加入下面一行username ALL=(ALL) ALL 1.Chrome的安装 先下载自动安装脚本：http://chrome.richardlloyd.org.uk/install_chrome.sh 然后使用gedit编辑install—chrome.sh，使用find功能查找并将其中的http://omahaproxy.appspot.com改为https://dl.google.com/linux/direct /google-chrome-stable_current_x86_64.rpm。 打开终端，依次执行 chmod u+x install_chrome.sh./install_chrome.sh 它会自动下载并安装最新版谷歌浏览器及相关依赖包。在终端下执行google-chrome就可以打开浏览器了。（注：须在非root用户下执行，若是在root登陆情况下指定其他用户执行带图形的google-chrome，要执行“xhost用户名”命令，授予该用户访问权限，这是因为Xserver默认情况下不允许别的用户的图形程序的图形显示在当前屏幕上。） 2.挂载NTFS分区 1、下载、编译安装ntfs-3g： #./configure #make #make install （得是root权限才能执行）2、查看USB设备点： #fdisk -l （得是root权限才能执行）Disk /dev/sdb: 60.0 GB, 60011642880 bytes255 heads, 63 sectors/track, 7296 cylindersUnits = cylinders of 16065 512 = 8225280 bytesDevice Boot Start End Blocks Id System/dev/sdb1 1 653 5245191 b W95 FAT32/dev/sdb2 654 7295 53351865 f W95 Ext’d (LBA)/dev/sdb5 654 1958 10482381 b W95 FAT32/dev/sdb6 1959 7295 42869421 7 HPFS/NTFS3、挂载NTFS分区： #mount -t ntfs-3g /dev/sda5 /mnt/win4、自启动如果想开机启动 就挂载上的话，编辑/etc/fstab 文件 如下：/dev/sda5 /mnt/win ntfs-3g defaults 0 0 3 .Error: Cannot find a valid baseurl for repo:问题解决可参考 : 默 读自我空间 4.sudo权限的赋予 sudo功能的配置文件一般在这里：/etc/sudoers，可以使用visudo编辑，好处是如果规则写的不符合要求能提示你，坏处是调出的是nano编辑器，甚为不顺手。而且/etc/sudoers的配置文件的注释里也说明了，不建议直接修改/etc/sudoers，而是通过在/etc/sudoers.d/文件夹中新增文件来完成配置。 Please consider adding local content in /etc/sudoers.d/ instead of directlymodifying this file. 新增的文件就用vi编辑就可以了，比如说要为mantou增加sudo权限，就增加一个文件，文件名无所谓，内容是： mantou ALL=(ALL) ALL 保存，退出vi 然后需要把这个文件权限设置为400：chmod 400 mantou 再用mantou用户登录后就可以使用sudo权限了。 5.rar和unrar安装 首先 vim /etc/yum.repos.d/dag.repo 添加如下内容： [dag] name=Dag RPM Repository for Red Hat Enterprise Linux baseurl=http://apt.sw.be/redhat/el$releasever/en/$basearch/dag gpgcheck=1 enabled=1 gpgkey=http://dag.wieers.com/rpm/packages/RPM-GPG-KEY.dag.txt 然后yum install rar unrar即可。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://ichenwin.github.io/tags/Linux/"}]},{"title":"Linux磁盘命令及分区","date":"2014-03-14T21:21:00.000Z","path":"2014/03/14/Linux磁盘命令及分区 /","text":"Linux分区1.挂载命令 mount 【-参数】 【设备名】 【挂载点】 2.卸载命令 umount 【设备名称】 3.查看磁盘使用情况 df 【-参数】 比如： df -l df -h 4.查看某个目录在那个分区 df 【目录全路径】 5.查看Linux系统分区具体情况 fdisk -l 6.分区/boot 200M/swap 物理内存的两倍(&lt;=256M）//home/usr","tags":[{"name":"Linux","slug":"Linux","permalink":"http://ichenwin.github.io/tags/Linux/"}]},{"title":"Linux上JDK、Eclipse的安装","date":"2014-03-13T22:46:00.000Z","path":"2014/03/13/Linux上JDK、Eclipse的安装 /","text":"一、jdk安装 1.package.iso挂载 mount /mnt/cdrom/ [卸载：umount /mnt/cdrom/] 2.cp 文件名 /home/ 3.cd /home4.安装 ./j2sdk-**.bin 5./etc/profile [环境配置文件] JAVA_HOME=/home/j2sdk*** PATH=$PATH:/home/j2sdk***/bin CLASSPATH=.:/home/j2sdkjre/lib/rt.jar export JAVA_HOME PATH CLASSPATH 二、eclipse安装 1.cp eclipse-SDK-**.tar.gz /home 2.安装 tar -zxvf ???.tar.gz 3.启动eclipse[进入图形界面] ./eclipse 三、Myeclipse安装 ./**.bin Java服务器：tomcat、jboss、weblogic、websphere、resin 四、tomcat安装 ./**.bin","tags":[{"name":"Linux","slug":"Linux","permalink":"http://ichenwin.github.io/tags/Linux/"}]},{"title":"Linux常用指令（1）","date":"2014-03-13T22:44:00.000Z","path":"2014/03/13/Linux常用指令（1） /","text":"一、系统操作 &lt;span style=&quot;font-size:18px;&quot;&gt;shutdown -h now【立刻关机】&lt;/span&gt; shutdown -r now 【立刻重启】 reboot 【立刻重启】logout 【注销】 二、root用户（su -) login：root password： Ctrl+Alt+F1 【命令行界面】 Alt+F7 【返回桌面】 startx 【开启图形界面】 三、vi编辑器 1.vi Hello.java 2.i 【insert插入模式】 3.esc 【返回命令模式】 4.: (1).wq 【退出并保存】 (2).q! 【退出但不保存】 5.ls (-l) 【文件列表（详细）】 6.编译Java javac Hello.java java Hello 四、C语言程序 1.编译gcc Hello.cpp 自动生成a.out文件 2.运行./a.out 3.也可指定生成文件名：gcc -o [filename] Hello.cpp 五、文件管理 ls (-l) 【列写目录下文件名（详细信息）】 pwd 【显示当前路径】 六、用户管理（管理员才有权限） useradd chen 【添加用户”chen”】 passwd chen【设置”chen”的密码（一定要跟用户名”chen”，否则，单单”passwd”修改的是管理员的密码）】 userdel chen 【删除用户”chen”】 userdel -r chen 【删除用户及用户主目录】 一、linux常用命令（1） 1.指定运行级别 命令：init [0123456] 0:关机 1：单用户 2：多用户状态没有网络服务 3：多用户、有网络 4：保留 5：图形界面 6：系统重启 3和5常最用，在/etc/inittab的id:5:initdefault:这行中的数字 systemctl set-default multi-user.target 设定默认为字符界面，也就是3systemctl set-default graphical.target 图形界面 5 2.解决修改错误配置的方法 在进入grub时，输入e 移至第二行，再输入e 再最后输入1 [单用户级别] pwd 显示当前工作目录 cd 更改目录 ls 列出文件或目录 ls -l 详细信息 -a 显示隐藏文件 mkdir 新建目录 rmdir 删除空目录 touch 建立空文件 cp 复制 cp -r dir1 dir2 递归复制其目录中的所有内容 mv 移动文件和改文件名 rm 删除文件和目录 rm -rf 强制递归删除目录中的所有内容 ln 建立符号链接 more 显示文件内容，带分页 less 显示文件内容，带分页 grep -n “shunping” aaa.java 文本中查询内容（-n显示行数） | 管道命令（把上一个命令的结果交给|后面的命令处理） find / -name aaa.java 根目录下查找aaa.java [filename] 管道定向命令，将结果写入指定文件（覆盖写） 如：ls -l &gt; aaa.txt [filename] 功能同上，追加写入 &lt; ls -ahl 查看文件所有组 chown 用户名 文件名 修改文件所有者 chgrp 组名 文件名 修改文件所在组 groupadd 组名 添加组 cat /etc/group 查看所有组，cat只能查看不能修改 vi /etc/group 可以修改 useradd -g 组名 用户名 创建用户，并分配到某组 vi/cat /etc/passwd 查看所有用户 who am i 查看当前用户 usermod -g 组名 用户名 修改用户所在组 usermod -d 目录 用户名 更改该用户登录的初始目录 -rw-r–r– “-“ 文件类型 “rw-” 文件所有者对该文件的权限 “r–” 文件所在组对该文件的权限 “r–” 其他组的用户对该文件的权限 r 可读（用4表示） w 可写（用2表示） x 可执行（用1表示） 修改文件访问权限 chmod 775 aa 运行指令末尾加：&amp; 后台运行","tags":[{"name":"Linux","slug":"Linux","permalink":"http://ichenwin.github.io/tags/Linux/"}]},{"title":"Fedora 20配置","date":"2014-03-11T23:43:00.000Z","path":"2014/03/11/Fedora 20配置 /","text":"转载自 51运维网 、 苏若年 （ffmpeg未成功） 51CTO 字体渲染Freetype： http://www.it165.net/os/html/201308/6103.html Goagent: http://linux.chinaitlab.com/administer/938694_2.html http://blog.dimpurr.com/ubuntu-gae/ 1.加入第三方源 版权(nonfree)和专利(free) sudo rpm -Uvh http://download1.rpmfusion.org/free/fedora/rpmfusion-free-release-stable.noarch.rpm sudo rpm -Uvh http://download1.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-stable.noarch.rpm sudo yum makecache 2.安装自动选择最快镜像插件 yum管理器自动搜索最快源下载 sudo yum -y install yum-fastestmirror ( yum -y install yum-plugin-fastestmirror ) 更多YUM插件可以运行$ sudo yum info yum-plugin-* 来查看 3.更新系统 sudo yum update 4.安装gnome管理工具 sudo yum install gnome-tweak-tool 如果使用了浏览器你可能发现firefox标题栏只有关闭按钮 标题栏添加“最大化/最小化/关闭”按钮 打开gnome-tweak-tool( super+space –&gt; utilitis –&gt; 优化工具，或者直接从终端启动)， 选择 shell –&gt; 管理标题栏上的按钮 –&gt; 全部 5.安装wget : sudo yum install wget 6.安装flash plugin: wget http://linuxdownload.adobe.com/adobe-release/adobe-release-x86_64-1.0-1.noarch.rpm sudo rpm -ivh adobe-release-x86_64-1.0-1.noarch.rpm sudo yum -y install flash-plugin 7.将输入法改为fcitx (1).首先,删除ibus sudo yum remove ibus gsettings set org.gnome.settings-daemon.plugins.keyboard active false (2).之后安装fcitx sudo yum install fcitx* (3).配置fcitx在~/.bashrc中添加: export GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx export XMODIFIERS=&quot;@im=fcitx&quot;","tags":[{"name":"Linux","slug":"Linux","permalink":"http://ichenwin.github.io/tags/Linux/"}]}]